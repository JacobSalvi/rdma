/* automatically generated by rust-bindgen 0.59.2 */

pub const IBV_ACCESS_OPTIONAL_FIRST: u32 = 1048576;
pub const IBV_DEVICE_RAW_SCATTER_FCS: u64 = 17179869184;
pub const IBV_DEVICE_PCI_WRITE_END_PADDING: u64 = 68719476736;
pub const IBV_PATH_RECORD_REVERSIBLE: u32 = 128;
pub const IBV_PATH_FLAG_GMP: u32 = 1;
pub const IBV_PATH_FLAG_PRIMARY: u32 = 2;
pub const IBV_PATH_FLAG_ALTERNATE: u32 = 4;
pub const IBV_PATH_FLAG_OUTBOUND: u32 = 8;
pub const IBV_PATH_FLAG_INBOUND: u32 = 16;
pub const IBV_PATH_FLAG_INBOUND_REVERSE: u32 = 32;
pub const IBV_PATH_FLAG_BIDIRECTIONAL: u32 = 40;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub const IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM: ib_uverbs_flow_action_esp_keymat = 0;
pub type ib_uverbs_flow_action_esp_keymat = ::std::os::raw::c_uint;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE: ib_uverbs_flow_action_esp_replay = 0;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP: ib_uverbs_flow_action_esp_replay = 1;
pub type ib_uverbs_flow_action_esp_replay = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap {
    pub __bindgen_anon_1: ib_uverbs_flow_action_esp_encap__bindgen_ty_1,
    pub __bindgen_anon_2: ib_uverbs_flow_action_esp_encap__bindgen_ty_2,
    pub len: __u16,
    pub type_: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    pub val_ptr: *mut ::std::os::raw::c_void,
    pub val_ptr_data_u64: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    pub next_ptr: *mut ib_uverbs_flow_action_esp_encap,
    pub next_ptr_data_u64: __u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ib_uverbs_flow_action_esp {
    pub spi: __u32,
    pub seq: __u32,
    pub tfc_pad: __u32,
    pub flags: __u32,
    pub hard_limit_pkts: __u64,
}
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH: ib_uverbs_advise_mr_advice = 0;
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE: ib_uverbs_advise_mr_advice = 1;
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT: ib_uverbs_advise_mr_advice = 2;
pub type ib_uverbs_advise_mr_advice = ::std::os::raw::c_uint;
pub const RDMA_DRIVER_UNKNOWN: rdma_driver_id = 0;
pub const RDMA_DRIVER_MLX5: rdma_driver_id = 1;
pub const RDMA_DRIVER_MLX4: rdma_driver_id = 2;
pub const RDMA_DRIVER_CXGB3: rdma_driver_id = 3;
pub const RDMA_DRIVER_CXGB4: rdma_driver_id = 4;
pub const RDMA_DRIVER_MTHCA: rdma_driver_id = 5;
pub const RDMA_DRIVER_BNXT_RE: rdma_driver_id = 6;
pub const RDMA_DRIVER_OCRDMA: rdma_driver_id = 7;
pub const RDMA_DRIVER_NES: rdma_driver_id = 8;
pub const RDMA_DRIVER_I40IW: rdma_driver_id = 9;
pub const RDMA_DRIVER_IRDMA: rdma_driver_id = 9;
pub const RDMA_DRIVER_VMW_PVRDMA: rdma_driver_id = 10;
pub const RDMA_DRIVER_QEDR: rdma_driver_id = 11;
pub const RDMA_DRIVER_HNS: rdma_driver_id = 12;
pub const RDMA_DRIVER_USNIC: rdma_driver_id = 13;
pub const RDMA_DRIVER_RXE: rdma_driver_id = 14;
pub const RDMA_DRIVER_HFI1: rdma_driver_id = 15;
pub const RDMA_DRIVER_QIB: rdma_driver_id = 16;
pub const RDMA_DRIVER_EFA: rdma_driver_id = 17;
pub const RDMA_DRIVER_SIW: rdma_driver_id = 18;
pub type rdma_driver_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_gid {
    pub raw: [u8; 16usize],
    pub global: ibv_gid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
pub const IBV_GID_TYPE_IB: ibv_gid_type = 0;
pub const IBV_GID_TYPE_ROCE_V1: ibv_gid_type = 1;
pub const IBV_GID_TYPE_ROCE_V2: ibv_gid_type = 2;
pub type ibv_gid_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_gid_entry {
    pub gid: ibv_gid,
    pub gid_index: u32,
    pub port_num: u32,
    pub gid_type: u32,
    pub ndev_ifindex: u32,
}
pub const IBV_NODE_UNKNOWN: ibv_node_type = -1;
pub const IBV_NODE_CA: ibv_node_type = 1;
pub const IBV_NODE_SWITCH: ibv_node_type = 2;
pub const IBV_NODE_ROUTER: ibv_node_type = 3;
pub const IBV_NODE_RNIC: ibv_node_type = 4;
pub const IBV_NODE_USNIC: ibv_node_type = 5;
pub const IBV_NODE_USNIC_UDP: ibv_node_type = 6;
pub const IBV_NODE_UNSPECIFIED: ibv_node_type = 7;
pub type ibv_node_type = ::std::os::raw::c_int;
pub const IBV_TRANSPORT_UNKNOWN: ibv_transport_type = -1;
pub const IBV_TRANSPORT_IB: ibv_transport_type = 0;
pub const IBV_TRANSPORT_IWARP: ibv_transport_type = 1;
pub const IBV_TRANSPORT_USNIC: ibv_transport_type = 2;
pub const IBV_TRANSPORT_USNIC_UDP: ibv_transport_type = 3;
pub const IBV_TRANSPORT_UNSPECIFIED: ibv_transport_type = 4;
pub type ibv_transport_type = ::std::os::raw::c_int;
pub const IBV_DEVICE_RESIZE_MAX_WR: ibv_device_cap_flags = 1;
pub const IBV_DEVICE_BAD_PKEY_CNTR: ibv_device_cap_flags = 2;
pub const IBV_DEVICE_BAD_QKEY_CNTR: ibv_device_cap_flags = 4;
pub const IBV_DEVICE_RAW_MULTI: ibv_device_cap_flags = 8;
pub const IBV_DEVICE_AUTO_PATH_MIG: ibv_device_cap_flags = 16;
pub const IBV_DEVICE_CHANGE_PHY_PORT: ibv_device_cap_flags = 32;
pub const IBV_DEVICE_UD_AV_PORT_ENFORCE: ibv_device_cap_flags = 64;
pub const IBV_DEVICE_CURR_QP_STATE_MOD: ibv_device_cap_flags = 128;
pub const IBV_DEVICE_SHUTDOWN_PORT: ibv_device_cap_flags = 256;
pub const IBV_DEVICE_INIT_TYPE: ibv_device_cap_flags = 512;
pub const IBV_DEVICE_PORT_ACTIVE_EVENT: ibv_device_cap_flags = 1024;
pub const IBV_DEVICE_SYS_IMAGE_GUID: ibv_device_cap_flags = 2048;
pub const IBV_DEVICE_RC_RNR_NAK_GEN: ibv_device_cap_flags = 4096;
pub const IBV_DEVICE_SRQ_RESIZE: ibv_device_cap_flags = 8192;
pub const IBV_DEVICE_N_NOTIFY_CQ: ibv_device_cap_flags = 16384;
pub const IBV_DEVICE_MEM_WINDOW: ibv_device_cap_flags = 131072;
pub const IBV_DEVICE_UD_IP_CSUM: ibv_device_cap_flags = 262144;
pub const IBV_DEVICE_XRC: ibv_device_cap_flags = 1048576;
pub const IBV_DEVICE_MEM_MGT_EXTENSIONS: ibv_device_cap_flags = 2097152;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2A: ibv_device_cap_flags = 8388608;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2B: ibv_device_cap_flags = 16777216;
pub const IBV_DEVICE_RC_IP_CSUM: ibv_device_cap_flags = 33554432;
pub const IBV_DEVICE_RAW_IP_CSUM: ibv_device_cap_flags = 67108864;
pub const IBV_DEVICE_MANAGED_FLOW_STEERING: ibv_device_cap_flags = 536870912;
pub type ibv_device_cap_flags = ::std::os::raw::c_uint;
pub const IBV_FORK_DISABLED: ibv_fork_status = 0;
pub const IBV_FORK_ENABLED: ibv_fork_status = 1;
pub const IBV_FORK_UNNEEDED: ibv_fork_status = 2;
pub type ibv_fork_status = ::std::os::raw::c_uint;
pub const IBV_ATOMIC_NONE: ibv_atomic_cap = 0;
pub const IBV_ATOMIC_HCA: ibv_atomic_cap = 1;
pub const IBV_ATOMIC_GLOB: ibv_atomic_cap = 2;
pub type ibv_atomic_cap = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_alloc_dm_attr {
    pub length: usize,
    pub log_align_req: u32,
    pub comp_mask: u32,
}
pub const IBV_DM_MASK_HANDLE: ibv_dm_mask = 1;
pub type ibv_dm_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: ::std::option::Option<
        unsafe extern "C" fn(
            dm: *mut ibv_dm,
            dm_offset: u64,
            host_addr: *const ::std::os::raw::c_void,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub memcpy_from_dm: ::std::option::Option<
        unsafe extern "C" fn(
            host_addr: *mut ::std::os::raw::c_void,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub comp_mask: u32,
    pub handle: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
pub const IBV_ODP_SUPPORT_SEND: ibv_odp_transport_cap_bits = 1;
pub const IBV_ODP_SUPPORT_RECV: ibv_odp_transport_cap_bits = 2;
pub const IBV_ODP_SUPPORT_WRITE: ibv_odp_transport_cap_bits = 4;
pub const IBV_ODP_SUPPORT_READ: ibv_odp_transport_cap_bits = 8;
pub const IBV_ODP_SUPPORT_ATOMIC: ibv_odp_transport_cap_bits = 16;
pub const IBV_ODP_SUPPORT_SRQ_RECV: ibv_odp_transport_cap_bits = 32;
pub type ibv_odp_transport_cap_bits = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
pub const IBV_ODP_SUPPORT: ibv_odp_general_caps = 1;
pub const IBV_ODP_SUPPORT_IMPLICIT: ibv_odp_general_caps = 2;
pub type ibv_odp_general_caps = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
pub const IBV_RX_HASH_FUNC_TOEPLITZ: ibv_rx_hash_function_flags = 1;
pub type ibv_rx_hash_function_flags = ::std::os::raw::c_uint;
pub const IBV_RX_HASH_SRC_IPV4: ibv_rx_hash_fields = 1;
pub const IBV_RX_HASH_DST_IPV4: ibv_rx_hash_fields = 2;
pub const IBV_RX_HASH_SRC_IPV6: ibv_rx_hash_fields = 4;
pub const IBV_RX_HASH_DST_IPV6: ibv_rx_hash_fields = 8;
pub const IBV_RX_HASH_SRC_PORT_TCP: ibv_rx_hash_fields = 16;
pub const IBV_RX_HASH_DST_PORT_TCP: ibv_rx_hash_fields = 32;
pub const IBV_RX_HASH_SRC_PORT_UDP: ibv_rx_hash_fields = 64;
pub const IBV_RX_HASH_DST_PORT_UDP: ibv_rx_hash_fields = 128;
pub const IBV_RX_HASH_IPSEC_SPI: ibv_rx_hash_fields = 256;
pub const IBV_RX_HASH_INNER: ibv_rx_hash_fields = 2147483648;
pub type ibv_rx_hash_fields = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
pub const IBV_RAW_PACKET_CAP_CVLAN_STRIPPING: ibv_raw_packet_caps = 1;
pub const IBV_RAW_PACKET_CAP_SCATTER_FCS: ibv_raw_packet_caps = 2;
pub const IBV_RAW_PACKET_CAP_IP_CSUM: ibv_raw_packet_caps = 4;
pub const IBV_RAW_PACKET_CAP_DELAY_DROP: ibv_raw_packet_caps = 8;
pub type ibv_raw_packet_caps = ::std::os::raw::c_uint;
pub const IBV_TM_CAP_RC: ibv_tm_cap_flags = 1;
pub type ibv_tm_cap_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
pub const IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP: ibv_pci_atomic_op_size = 1;
pub const IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP: ibv_pci_atomic_op_size = 2;
pub const IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP: ibv_pci_atomic_op_size = 4;
pub type ibv_pci_atomic_op_size = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_pci_atomic_caps {
    pub fetch_add: u16,
    pub swap: u16,
    pub compare_swap: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
    pub pci_atomic_caps: ibv_pci_atomic_caps,
    pub xrc_odp_caps: u32,
    pub phys_port_cnt_ex: u32,
}
pub const IBV_MTU_256: ibv_mtu = 1;
pub const IBV_MTU_512: ibv_mtu = 2;
pub const IBV_MTU_1024: ibv_mtu = 3;
pub const IBV_MTU_2048: ibv_mtu = 4;
pub const IBV_MTU_4096: ibv_mtu = 5;
pub type ibv_mtu = ::std::os::raw::c_uint;
pub const IBV_PORT_NOP: ibv_port_state = 0;
pub const IBV_PORT_DOWN: ibv_port_state = 1;
pub const IBV_PORT_INIT: ibv_port_state = 2;
pub const IBV_PORT_ARMED: ibv_port_state = 3;
pub const IBV_PORT_ACTIVE: ibv_port_state = 4;
pub const IBV_PORT_ACTIVE_DEFER: ibv_port_state = 5;
pub type ibv_port_state = ::std::os::raw::c_uint;
pub const IBV_LINK_LAYER_UNSPECIFIED: ::std::os::raw::c_uint = 0;
pub const IBV_LINK_LAYER_INFINIBAND: ::std::os::raw::c_uint = 1;
pub const IBV_LINK_LAYER_ETHERNET: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const IBV_PORT_SM: ibv_port_cap_flags = 2;
pub const IBV_PORT_NOTICE_SUP: ibv_port_cap_flags = 4;
pub const IBV_PORT_TRAP_SUP: ibv_port_cap_flags = 8;
pub const IBV_PORT_OPT_IPD_SUP: ibv_port_cap_flags = 16;
pub const IBV_PORT_AUTO_MIGR_SUP: ibv_port_cap_flags = 32;
pub const IBV_PORT_SL_MAP_SUP: ibv_port_cap_flags = 64;
pub const IBV_PORT_MKEY_NVRAM: ibv_port_cap_flags = 128;
pub const IBV_PORT_PKEY_NVRAM: ibv_port_cap_flags = 256;
pub const IBV_PORT_LED_INFO_SUP: ibv_port_cap_flags = 512;
pub const IBV_PORT_SYS_IMAGE_GUID_SUP: ibv_port_cap_flags = 2048;
pub const IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP: ibv_port_cap_flags = 4096;
pub const IBV_PORT_EXTENDED_SPEEDS_SUP: ibv_port_cap_flags = 16384;
pub const IBV_PORT_CAP_MASK2_SUP: ibv_port_cap_flags = 32768;
pub const IBV_PORT_CM_SUP: ibv_port_cap_flags = 65536;
pub const IBV_PORT_SNMP_TUNNEL_SUP: ibv_port_cap_flags = 131072;
pub const IBV_PORT_REINIT_SUP: ibv_port_cap_flags = 262144;
pub const IBV_PORT_DEVICE_MGMT_SUP: ibv_port_cap_flags = 524288;
pub const IBV_PORT_VENDOR_CLASS_SUP: ibv_port_cap_flags = 1048576;
pub const IBV_PORT_DR_NOTICE_SUP: ibv_port_cap_flags = 2097152;
pub const IBV_PORT_CAP_MASK_NOTICE_SUP: ibv_port_cap_flags = 4194304;
pub const IBV_PORT_BOOT_MGMT_SUP: ibv_port_cap_flags = 8388608;
pub const IBV_PORT_LINK_LATENCY_SUP: ibv_port_cap_flags = 16777216;
pub const IBV_PORT_CLIENT_REG_SUP: ibv_port_cap_flags = 33554432;
pub const IBV_PORT_IP_BASED_GIDS: ibv_port_cap_flags = 67108864;
pub type ibv_port_cap_flags = ::std::os::raw::c_uint;
pub const IBV_PORT_SET_NODE_DESC_SUP: ibv_port_cap_flags2 = 1;
pub const IBV_PORT_INFO_EXT_SUP: ibv_port_cap_flags2 = 2;
pub const IBV_PORT_VIRT_SUP: ibv_port_cap_flags2 = 4;
pub const IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP: ibv_port_cap_flags2 = 8;
pub const IBV_PORT_LINK_WIDTH_2X_SUP: ibv_port_cap_flags2 = 16;
pub const IBV_PORT_LINK_SPEED_HDR_SUP: ibv_port_cap_flags2 = 32;
pub const IBV_PORT_LINK_SPEED_NDR_SUP: ibv_port_cap_flags2 = 1024;
pub type ibv_port_cap_flags2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_port_attr {
    pub state: ibv_port_state,
    pub max_mtu: ibv_mtu,
    pub active_mtu: ibv_mtu,
    pub gid_tbl_len: ::std::os::raw::c_int,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub port_cap_flags2: u16,
}
pub const IBV_EVENT_CQ_ERR: ibv_event_type = 0;
pub const IBV_EVENT_QP_FATAL: ibv_event_type = 1;
pub const IBV_EVENT_QP_REQ_ERR: ibv_event_type = 2;
pub const IBV_EVENT_QP_ACCESS_ERR: ibv_event_type = 3;
pub const IBV_EVENT_COMM_EST: ibv_event_type = 4;
pub const IBV_EVENT_SQ_DRAINED: ibv_event_type = 5;
pub const IBV_EVENT_PATH_MIG: ibv_event_type = 6;
pub const IBV_EVENT_PATH_MIG_ERR: ibv_event_type = 7;
pub const IBV_EVENT_DEVICE_FATAL: ibv_event_type = 8;
pub const IBV_EVENT_PORT_ACTIVE: ibv_event_type = 9;
pub const IBV_EVENT_PORT_ERR: ibv_event_type = 10;
pub const IBV_EVENT_LID_CHANGE: ibv_event_type = 11;
pub const IBV_EVENT_PKEY_CHANGE: ibv_event_type = 12;
pub const IBV_EVENT_SM_CHANGE: ibv_event_type = 13;
pub const IBV_EVENT_SRQ_ERR: ibv_event_type = 14;
pub const IBV_EVENT_SRQ_LIMIT_REACHED: ibv_event_type = 15;
pub const IBV_EVENT_QP_LAST_WQE_REACHED: ibv_event_type = 16;
pub const IBV_EVENT_CLIENT_REREGISTER: ibv_event_type = 17;
pub const IBV_EVENT_GID_CHANGE: ibv_event_type = 18;
pub const IBV_EVENT_WQ_FATAL: ibv_event_type = 19;
pub type ibv_event_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_async_event {
    pub element: ibv_async_event__bindgen_ty_1,
    pub event_type: ibv_event_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_async_event__bindgen_ty_1 {
    pub cq: *mut ibv_cq,
    pub qp: *mut ibv_qp,
    pub srq: *mut ibv_srq,
    pub wq: *mut ibv_wq,
    pub port_num: ::std::os::raw::c_int,
}
pub const IBV_WC_SUCCESS: ibv_wc_status = 0;
pub const IBV_WC_LOC_LEN_ERR: ibv_wc_status = 1;
pub const IBV_WC_LOC_QP_OP_ERR: ibv_wc_status = 2;
pub const IBV_WC_LOC_EEC_OP_ERR: ibv_wc_status = 3;
pub const IBV_WC_LOC_PROT_ERR: ibv_wc_status = 4;
pub const IBV_WC_WR_FLUSH_ERR: ibv_wc_status = 5;
pub const IBV_WC_MW_BIND_ERR: ibv_wc_status = 6;
pub const IBV_WC_BAD_RESP_ERR: ibv_wc_status = 7;
pub const IBV_WC_LOC_ACCESS_ERR: ibv_wc_status = 8;
pub const IBV_WC_REM_INV_REQ_ERR: ibv_wc_status = 9;
pub const IBV_WC_REM_ACCESS_ERR: ibv_wc_status = 10;
pub const IBV_WC_REM_OP_ERR: ibv_wc_status = 11;
pub const IBV_WC_RETRY_EXC_ERR: ibv_wc_status = 12;
pub const IBV_WC_RNR_RETRY_EXC_ERR: ibv_wc_status = 13;
pub const IBV_WC_LOC_RDD_VIOL_ERR: ibv_wc_status = 14;
pub const IBV_WC_REM_INV_RD_REQ_ERR: ibv_wc_status = 15;
pub const IBV_WC_REM_ABORT_ERR: ibv_wc_status = 16;
pub const IBV_WC_INV_EECN_ERR: ibv_wc_status = 17;
pub const IBV_WC_INV_EEC_STATE_ERR: ibv_wc_status = 18;
pub const IBV_WC_FATAL_ERR: ibv_wc_status = 19;
pub const IBV_WC_RESP_TIMEOUT_ERR: ibv_wc_status = 20;
pub const IBV_WC_GENERAL_ERR: ibv_wc_status = 21;
pub const IBV_WC_TM_ERR: ibv_wc_status = 22;
pub const IBV_WC_TM_RNDV_INCOMPLETE: ibv_wc_status = 23;
pub type ibv_wc_status = ::std::os::raw::c_uint;
extern "C" {
    pub fn ibv_wc_status_str(status: ibv_wc_status) -> *const ::std::os::raw::c_char;
}
pub const IBV_WC_SEND: ibv_wc_opcode = 0;
pub const IBV_WC_RDMA_WRITE: ibv_wc_opcode = 1;
pub const IBV_WC_RDMA_READ: ibv_wc_opcode = 2;
pub const IBV_WC_COMP_SWAP: ibv_wc_opcode = 3;
pub const IBV_WC_FETCH_ADD: ibv_wc_opcode = 4;
pub const IBV_WC_BIND_MW: ibv_wc_opcode = 5;
pub const IBV_WC_LOCAL_INV: ibv_wc_opcode = 6;
pub const IBV_WC_TSO: ibv_wc_opcode = 7;
pub const IBV_WC_RECV: ibv_wc_opcode = 128;
pub const IBV_WC_RECV_RDMA_WITH_IMM: ibv_wc_opcode = 129;
pub const IBV_WC_TM_ADD: ibv_wc_opcode = 130;
pub const IBV_WC_TM_DEL: ibv_wc_opcode = 131;
pub const IBV_WC_TM_SYNC: ibv_wc_opcode = 132;
pub const IBV_WC_TM_RECV: ibv_wc_opcode = 133;
pub const IBV_WC_TM_NO_TAG: ibv_wc_opcode = 134;
pub const IBV_WC_DRIVER1: ibv_wc_opcode = 135;
pub const IBV_WC_DRIVER2: ibv_wc_opcode = 136;
pub const IBV_WC_DRIVER3: ibv_wc_opcode = 137;
pub type ibv_wc_opcode = ::std::os::raw::c_uint;
pub const IBV_WC_IP_CSUM_OK_SHIFT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const IBV_WC_EX_WITH_BYTE_LEN: ibv_create_cq_wc_flags = 1;
pub const IBV_WC_EX_WITH_IMM: ibv_create_cq_wc_flags = 2;
pub const IBV_WC_EX_WITH_QP_NUM: ibv_create_cq_wc_flags = 4;
pub const IBV_WC_EX_WITH_SRC_QP: ibv_create_cq_wc_flags = 8;
pub const IBV_WC_EX_WITH_SLID: ibv_create_cq_wc_flags = 16;
pub const IBV_WC_EX_WITH_SL: ibv_create_cq_wc_flags = 32;
pub const IBV_WC_EX_WITH_DLID_PATH_BITS: ibv_create_cq_wc_flags = 64;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP: ibv_create_cq_wc_flags = 128;
pub const IBV_WC_EX_WITH_CVLAN: ibv_create_cq_wc_flags = 256;
pub const IBV_WC_EX_WITH_FLOW_TAG: ibv_create_cq_wc_flags = 512;
pub const IBV_WC_EX_WITH_TM_INFO: ibv_create_cq_wc_flags = 1024;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP_WALLCLOCK: ibv_create_cq_wc_flags = 2048;
pub type ibv_create_cq_wc_flags = ::std::os::raw::c_uint;
pub const IBV_WC_STANDARD_FLAGS: ::std::os::raw::c_uint = 127;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const IBV_CREATE_CQ_SUP_WC_FLAGS: ::std::os::raw::c_uint = 4095;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const IBV_WC_GRH: ibv_wc_flags = 1;
pub const IBV_WC_WITH_IMM: ibv_wc_flags = 2;
pub const IBV_WC_IP_CSUM_OK: ibv_wc_flags = 4;
pub const IBV_WC_WITH_INV: ibv_wc_flags = 8;
pub const IBV_WC_TM_SYNC_REQ: ibv_wc_flags = 16;
pub const IBV_WC_TM_MATCH: ibv_wc_flags = 32;
pub const IBV_WC_TM_DATA_VALID: ibv_wc_flags = 64;
pub type ibv_wc_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status,
    pub opcode: ibv_wc_opcode,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
}
pub const IBV_ACCESS_LOCAL_WRITE: ibv_access_flags = 1;
pub const IBV_ACCESS_REMOTE_WRITE: ibv_access_flags = 2;
pub const IBV_ACCESS_REMOTE_READ: ibv_access_flags = 4;
pub const IBV_ACCESS_REMOTE_ATOMIC: ibv_access_flags = 8;
pub const IBV_ACCESS_MW_BIND: ibv_access_flags = 16;
pub const IBV_ACCESS_ZERO_BASED: ibv_access_flags = 32;
pub const IBV_ACCESS_ON_DEMAND: ibv_access_flags = 64;
pub const IBV_ACCESS_HUGETLB: ibv_access_flags = 128;
pub const IBV_ACCESS_RELAXED_ORDERING: ibv_access_flags = 1048576;
pub type ibv_access_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_td_init_attr {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_td {
    pub context: *mut ibv_context,
}
pub const IBV_XRCD_INIT_ATTR_FD: ibv_xrcd_init_attr_mask = 1;
pub const IBV_XRCD_INIT_ATTR_OFLAGS: ibv_xrcd_init_attr_mask = 2;
pub const IBV_XRCD_INIT_ATTR_RESERVED: ibv_xrcd_init_attr_mask = 4;
pub type ibv_xrcd_init_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_xrcd_init_attr {
    pub comp_mask: u32,
    pub fd: ::std::os::raw::c_int,
    pub oflags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
pub const IBV_REREG_MR_CHANGE_TRANSLATION: ibv_rereg_mr_flags = 1;
pub const IBV_REREG_MR_CHANGE_PD: ibv_rereg_mr_flags = 2;
pub const IBV_REREG_MR_CHANGE_ACCESS: ibv_rereg_mr_flags = 4;
pub const IBV_REREG_MR_FLAGS_SUPPORTED: ibv_rereg_mr_flags = 7;
pub type ibv_rereg_mr_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
pub const IBV_MW_TYPE_1: ibv_mw_type = 1;
pub const IBV_MW_TYPE_2: ibv_mw_type = 2;
pub type ibv_mw_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_global_route {
    pub dgid: ibv_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_grh {
    pub version_tclass_flow: __be32,
    pub paylen: __be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
}
pub const IBV_RATE_MAX: ibv_rate = 0;
pub const IBV_RATE_2_5_GBPS: ibv_rate = 2;
pub const IBV_RATE_5_GBPS: ibv_rate = 5;
pub const IBV_RATE_10_GBPS: ibv_rate = 3;
pub const IBV_RATE_20_GBPS: ibv_rate = 6;
pub const IBV_RATE_30_GBPS: ibv_rate = 4;
pub const IBV_RATE_40_GBPS: ibv_rate = 7;
pub const IBV_RATE_60_GBPS: ibv_rate = 8;
pub const IBV_RATE_80_GBPS: ibv_rate = 9;
pub const IBV_RATE_120_GBPS: ibv_rate = 10;
pub const IBV_RATE_14_GBPS: ibv_rate = 11;
pub const IBV_RATE_56_GBPS: ibv_rate = 12;
pub const IBV_RATE_112_GBPS: ibv_rate = 13;
pub const IBV_RATE_168_GBPS: ibv_rate = 14;
pub const IBV_RATE_25_GBPS: ibv_rate = 15;
pub const IBV_RATE_100_GBPS: ibv_rate = 16;
pub const IBV_RATE_200_GBPS: ibv_rate = 17;
pub const IBV_RATE_300_GBPS: ibv_rate = 18;
pub const IBV_RATE_28_GBPS: ibv_rate = 19;
pub const IBV_RATE_50_GBPS: ibv_rate = 20;
pub const IBV_RATE_400_GBPS: ibv_rate = 21;
pub const IBV_RATE_600_GBPS: ibv_rate = 22;
pub const IBV_RATE_800_GBPS: ibv_rate = 23;
pub const IBV_RATE_1200_GBPS: ibv_rate = 24;
pub type ibv_rate = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " ibv_rate_to_mult - Convert the IB rate enum to a multiple of the"]
    #[doc = " base rate of 2.5 Gbit/sec.  For example, IBV_RATE_5_GBPS will be"]
    #[doc = " converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec."]
    #[doc = " @rate: rate to convert."]
    pub fn ibv_rate_to_mult(rate: ibv_rate) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_rate_to_mbps - Convert the IB rate enum to Mbit/sec."]
    #[doc = " For example, IBV_RATE_5_GBPS will return the value 5000."]
    #[doc = " @rate: rate to convert."]
    pub fn ibv_rate_to_mbps(rate: ibv_rate) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah_attr {
    pub grh: ibv_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
pub const IBV_SRQ_MAX_WR: ibv_srq_attr_mask = 1;
pub const IBV_SRQ_LIMIT: ibv_srq_attr_mask = 2;
pub type ibv_srq_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
}
pub const IBV_SRQT_BASIC: ibv_srq_type = 0;
pub const IBV_SRQT_XRC: ibv_srq_type = 1;
pub const IBV_SRQT_TM: ibv_srq_type = 2;
pub type ibv_srq_type = ::std::os::raw::c_uint;
pub const IBV_SRQ_INIT_ATTR_TYPE: ibv_srq_init_attr_mask = 1;
pub const IBV_SRQ_INIT_ATTR_PD: ibv_srq_init_attr_mask = 2;
pub const IBV_SRQ_INIT_ATTR_XRCD: ibv_srq_init_attr_mask = 4;
pub const IBV_SRQ_INIT_ATTR_CQ: ibv_srq_init_attr_mask = 8;
pub const IBV_SRQ_INIT_ATTR_TM: ibv_srq_init_attr_mask = 16;
pub const IBV_SRQ_INIT_ATTR_RESERVED: ibv_srq_init_attr_mask = 32;
pub type ibv_srq_init_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_tm_cap {
    pub max_num_tags: u32,
    pub max_ops: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr_ex {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
    pub comp_mask: u32,
    pub srq_type: ibv_srq_type,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub cq: *mut ibv_cq,
    pub tm_cap: ibv_tm_cap,
}
pub const IBV_WQT_RQ: ibv_wq_type = 0;
pub type ibv_wq_type = ::std::os::raw::c_uint;
pub const IBV_WQ_INIT_ATTR_FLAGS: ibv_wq_init_attr_mask = 1;
pub const IBV_WQ_INIT_ATTR_RESERVED: ibv_wq_init_attr_mask = 2;
pub type ibv_wq_init_attr_mask = ::std::os::raw::c_uint;
pub const IBV_WQ_FLAGS_CVLAN_STRIPPING: ibv_wq_flags = 1;
pub const IBV_WQ_FLAGS_SCATTER_FCS: ibv_wq_flags = 2;
pub const IBV_WQ_FLAGS_DELAY_DROP: ibv_wq_flags = 4;
pub const IBV_WQ_FLAGS_PCI_WRITE_END_PADDING: ibv_wq_flags = 8;
pub const IBV_WQ_FLAGS_RESERVED: ibv_wq_flags = 16;
pub type ibv_wq_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut ::std::os::raw::c_void,
    pub wq_type: ibv_wq_type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
pub const IBV_WQS_RESET: ibv_wq_state = 0;
pub const IBV_WQS_RDY: ibv_wq_state = 1;
pub const IBV_WQS_ERR: ibv_wq_state = 2;
pub const IBV_WQS_UNKNOWN: ibv_wq_state = 3;
pub type ibv_wq_state = ::std::os::raw::c_uint;
pub const IBV_WQ_ATTR_STATE: ibv_wq_attr_mask = 1;
pub const IBV_WQ_ATTR_CURR_STATE: ibv_wq_attr_mask = 2;
pub const IBV_WQ_ATTR_FLAGS: ibv_wq_attr_mask = 4;
pub const IBV_WQ_ATTR_RESERVED: ibv_wq_attr_mask = 8;
pub type ibv_wq_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state,
    pub curr_wq_state: ibv_wq_state,
    pub flags: u32,
    pub flags_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: ::std::os::raw::c_int,
    pub ind_tbl_num: ::std::os::raw::c_int,
    pub comp_mask: u32,
}
pub const IBV_CREATE_IND_TABLE_RESERVED: ibv_ind_table_init_attr_mask = 1;
pub type ibv_ind_table_init_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
pub const IBV_QPT_RC: ibv_qp_type = 2;
pub const IBV_QPT_UC: ibv_qp_type = 3;
pub const IBV_QPT_UD: ibv_qp_type = 4;
pub const IBV_QPT_RAW_PACKET: ibv_qp_type = 8;
pub const IBV_QPT_XRC_SEND: ibv_qp_type = 9;
pub const IBV_QPT_XRC_RECV: ibv_qp_type = 10;
pub const IBV_QPT_DRIVER: ibv_qp_type = 255;
pub type ibv_qp_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: ::std::os::raw::c_int,
}
pub const IBV_QP_INIT_ATTR_PD: ibv_qp_init_attr_mask = 1;
pub const IBV_QP_INIT_ATTR_XRCD: ibv_qp_init_attr_mask = 2;
pub const IBV_QP_INIT_ATTR_CREATE_FLAGS: ibv_qp_init_attr_mask = 4;
pub const IBV_QP_INIT_ATTR_MAX_TSO_HEADER: ibv_qp_init_attr_mask = 8;
pub const IBV_QP_INIT_ATTR_IND_TABLE: ibv_qp_init_attr_mask = 16;
pub const IBV_QP_INIT_ATTR_RX_HASH: ibv_qp_init_attr_mask = 32;
pub const IBV_QP_INIT_ATTR_SEND_OPS_FLAGS: ibv_qp_init_attr_mask = 64;
pub type ibv_qp_init_attr_mask = ::std::os::raw::c_uint;
pub const IBV_QP_CREATE_BLOCK_SELF_MCAST_LB: ibv_qp_create_flags = 2;
pub const IBV_QP_CREATE_SCATTER_FCS: ibv_qp_create_flags = 256;
pub const IBV_QP_CREATE_CVLAN_STRIPPING: ibv_qp_create_flags = 512;
pub const IBV_QP_CREATE_SOURCE_QPN: ibv_qp_create_flags = 1024;
pub const IBV_QP_CREATE_PCI_WRITE_END_PADDING: ibv_qp_create_flags = 2048;
pub type ibv_qp_create_flags = ::std::os::raw::c_uint;
pub const IBV_QP_EX_WITH_RDMA_WRITE: ibv_qp_create_send_ops_flags = 1;
pub const IBV_QP_EX_WITH_RDMA_WRITE_WITH_IMM: ibv_qp_create_send_ops_flags = 2;
pub const IBV_QP_EX_WITH_SEND: ibv_qp_create_send_ops_flags = 4;
pub const IBV_QP_EX_WITH_SEND_WITH_IMM: ibv_qp_create_send_ops_flags = 8;
pub const IBV_QP_EX_WITH_RDMA_READ: ibv_qp_create_send_ops_flags = 16;
pub const IBV_QP_EX_WITH_ATOMIC_CMP_AND_SWP: ibv_qp_create_send_ops_flags = 32;
pub const IBV_QP_EX_WITH_ATOMIC_FETCH_AND_ADD: ibv_qp_create_send_ops_flags = 64;
pub const IBV_QP_EX_WITH_LOCAL_INV: ibv_qp_create_send_ops_flags = 128;
pub const IBV_QP_EX_WITH_BIND_MW: ibv_qp_create_send_ops_flags = 256;
pub const IBV_QP_EX_WITH_SEND_WITH_INV: ibv_qp_create_send_ops_flags = 512;
pub const IBV_QP_EX_WITH_TSO: ibv_qp_create_send_ops_flags = 1024;
pub type ibv_qp_create_send_ops_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: ::std::os::raw::c_int,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
    pub send_ops_flags: u64,
}
pub const IBV_QP_OPEN_ATTR_NUM: ibv_qp_open_attr_mask = 1;
pub const IBV_QP_OPEN_ATTR_XRCD: ibv_qp_open_attr_mask = 2;
pub const IBV_QP_OPEN_ATTR_CONTEXT: ibv_qp_open_attr_mask = 4;
pub const IBV_QP_OPEN_ATTR_TYPE: ibv_qp_open_attr_mask = 8;
pub const IBV_QP_OPEN_ATTR_RESERVED: ibv_qp_open_attr_mask = 16;
pub type ibv_qp_open_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_open_attr {
    pub comp_mask: u32,
    pub qp_num: u32,
    pub xrcd: *mut ibv_xrcd,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub qp_type: ibv_qp_type,
}
pub const IBV_QP_STATE: ibv_qp_attr_mask = 1;
pub const IBV_QP_CUR_STATE: ibv_qp_attr_mask = 2;
pub const IBV_QP_EN_SQD_ASYNC_NOTIFY: ibv_qp_attr_mask = 4;
pub const IBV_QP_ACCESS_FLAGS: ibv_qp_attr_mask = 8;
pub const IBV_QP_PKEY_INDEX: ibv_qp_attr_mask = 16;
pub const IBV_QP_PORT: ibv_qp_attr_mask = 32;
pub const IBV_QP_QKEY: ibv_qp_attr_mask = 64;
pub const IBV_QP_AV: ibv_qp_attr_mask = 128;
pub const IBV_QP_PATH_MTU: ibv_qp_attr_mask = 256;
pub const IBV_QP_TIMEOUT: ibv_qp_attr_mask = 512;
pub const IBV_QP_RETRY_CNT: ibv_qp_attr_mask = 1024;
pub const IBV_QP_RNR_RETRY: ibv_qp_attr_mask = 2048;
pub const IBV_QP_RQ_PSN: ibv_qp_attr_mask = 4096;
pub const IBV_QP_MAX_QP_RD_ATOMIC: ibv_qp_attr_mask = 8192;
pub const IBV_QP_ALT_PATH: ibv_qp_attr_mask = 16384;
pub const IBV_QP_MIN_RNR_TIMER: ibv_qp_attr_mask = 32768;
pub const IBV_QP_SQ_PSN: ibv_qp_attr_mask = 65536;
pub const IBV_QP_MAX_DEST_RD_ATOMIC: ibv_qp_attr_mask = 131072;
pub const IBV_QP_PATH_MIG_STATE: ibv_qp_attr_mask = 262144;
pub const IBV_QP_CAP: ibv_qp_attr_mask = 524288;
pub const IBV_QP_DEST_QPN: ibv_qp_attr_mask = 1048576;
pub const IBV_QP_RATE_LIMIT: ibv_qp_attr_mask = 33554432;
pub type ibv_qp_attr_mask = ::std::os::raw::c_uint;
pub const IBV_QPS_RESET: ibv_qp_state = 0;
pub const IBV_QPS_INIT: ibv_qp_state = 1;
pub const IBV_QPS_RTR: ibv_qp_state = 2;
pub const IBV_QPS_RTS: ibv_qp_state = 3;
pub const IBV_QPS_SQD: ibv_qp_state = 4;
pub const IBV_QPS_SQE: ibv_qp_state = 5;
pub const IBV_QPS_ERR: ibv_qp_state = 6;
pub const IBV_QPS_UNKNOWN: ibv_qp_state = 7;
pub type ibv_qp_state = ::std::os::raw::c_uint;
pub const IBV_MIG_MIGRATED: ibv_mig_state = 0;
pub const IBV_MIG_REARM: ibv_mig_state = 1;
pub const IBV_MIG_ARMED: ibv_mig_state = 2;
pub type ibv_mig_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state,
    pub cur_qp_state: ibv_qp_state,
    pub path_mtu: ibv_mtu,
    pub path_mig_state: ibv_mig_state,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: ::std::os::raw::c_uint,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_rate_limit_attr {
    pub rate_limit: u32,
    pub max_burst_sz: u32,
    pub typical_pkt_sz: u16,
    pub comp_mask: u32,
}
pub const IBV_WR_RDMA_WRITE: ibv_wr_opcode = 0;
pub const IBV_WR_RDMA_WRITE_WITH_IMM: ibv_wr_opcode = 1;
pub const IBV_WR_SEND: ibv_wr_opcode = 2;
pub const IBV_WR_SEND_WITH_IMM: ibv_wr_opcode = 3;
pub const IBV_WR_RDMA_READ: ibv_wr_opcode = 4;
pub const IBV_WR_ATOMIC_CMP_AND_SWP: ibv_wr_opcode = 5;
pub const IBV_WR_ATOMIC_FETCH_AND_ADD: ibv_wr_opcode = 6;
pub const IBV_WR_LOCAL_INV: ibv_wr_opcode = 7;
pub const IBV_WR_BIND_MW: ibv_wr_opcode = 8;
pub const IBV_WR_SEND_WITH_INV: ibv_wr_opcode = 9;
pub const IBV_WR_TSO: ibv_wr_opcode = 10;
pub const IBV_WR_DRIVER1: ibv_wr_opcode = 11;
pub type ibv_wr_opcode = ::std::os::raw::c_uint;
pub const IBV_SEND_FENCE: ibv_send_flags = 1;
pub const IBV_SEND_SIGNALED: ibv_send_flags = 2;
pub const IBV_SEND_SOLICITED: ibv_send_flags = 4;
pub const IBV_SEND_INLINE: ibv_send_flags = 8;
pub const IBV_SEND_IP_CSUM: ibv_send_flags = 16;
pub type ibv_send_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_data_buf {
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
pub const IBV_WR_TAG_ADD: ibv_ops_wr_opcode = 0;
pub const IBV_WR_TAG_DEL: ibv_ops_wr_opcode = 1;
pub const IBV_WR_TAG_SYNC: ibv_ops_wr_opcode = 2;
pub type ibv_ops_wr_opcode = ::std::os::raw::c_uint;
pub const IBV_OPS_SIGNALED: ibv_ops_flags = 1;
pub const IBV_OPS_TM_SYNC: ibv_ops_flags = 2;
pub type ibv_ops_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr {
    pub wr_id: u64,
    pub next: *mut ibv_ops_wr,
    pub opcode: ibv_ops_wr_opcode,
    pub flags: ::std::os::raw::c_int,
    pub tm: ibv_ops_wr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1 {
    pub unexpected_cnt: u32,
    pub handle: u32,
    pub add: ibv_ops_wr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    pub recv_wr_id: u64,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub tag: u64,
    pub mask: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state,
    pub wq_type: ibv_wq_type,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_wq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
#[repr(C)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state,
    pub qp_type: ibv_qp_type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[repr(C)]
pub struct ibv_qp_ex {
    pub qp_base: ibv_qp,
    pub comp_mask: u64,
    pub wr_id: u64,
    pub wr_flags: ::std::os::raw::c_uint,
    pub wr_atomic_cmp_swp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            rkey: u32,
            remote_addr: u64,
            compare: u64,
            swap: u64,
        ),
    >,
    pub wr_atomic_fetch_add: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, add: u64),
    >,
    pub wr_bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            mw: *mut ibv_mw,
            rkey: u32,
            bind_info: *const ibv_mw_bind_info,
        ),
    >,
    pub wr_local_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_rdma_read: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write_imm: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, imm_data: __be32),
    >,
    pub wr_send: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_send_imm:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, imm_data: __be32)>,
    pub wr_send_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_send_tso: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            hdr: *mut ::std::os::raw::c_void,
            hdr_sz: u16,
            mss: u16,
        ),
    >,
    pub wr_set_ud_addr: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            ah: *mut ibv_ah,
            remote_qpn: u32,
            remote_qkey: u32,
        ),
    >,
    pub wr_set_xrc_srqn:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, remote_srqn: u32)>,
    pub wr_set_inline_data: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, addr: *mut ::std::os::raw::c_void, length: usize),
    >,
    pub wr_set_inline_data_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_buf: usize, buf_list: *const ibv_data_buf),
    >,
    pub wr_set_sge: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, lkey: u32, addr: u64, length: u32),
    >,
    pub wr_set_sge_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_sge: usize, sg_list: *const ibv_sge),
    >,
    pub wr_start: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_complete:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex) -> ::std::os::raw::c_int>,
    pub wr_abort: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
}
extern "C" {
    pub fn ibv_qp_to_qp_ex(qp: *mut ibv_qp) -> *mut ibv_qp_ex;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ece {
    pub vendor_id: u32,
    pub options: u32,
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[repr(C)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub priv_: u32,
}
#[repr(C)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status,
    pub wr_id: u64,
    pub start_poll: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_cq_ex,
            attr: *mut ibv_poll_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_poll: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_int,
    >,
    pub end_poll: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex)>,
    pub read_opcode:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ibv_wc_opcode>,
    pub read_vendor_err:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_byte_len: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_imm_data:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> __be32>,
    pub read_qp_num: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_src_qp: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_wc_flags: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_uint,
    >,
    pub read_slid: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_sl: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_dlid_path_bits:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_completion_ts:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
    pub read_cvlan: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u16>,
    pub read_flow_tag: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_tm_info: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex, tm_info: *mut ibv_wc_tm_info),
    >,
    pub read_completion_wallclock_ns:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
}
pub const IBV_CQ_ATTR_MODERATE: ibv_cq_attr_mask = 1;
pub const IBV_CQ_ATTR_RESERVED: ibv_cq_attr_mask = 2;
pub type ibv_cq_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_moderate_cq {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_modify_cq_attr {
    pub attr_mask: u32,
    pub moderate: ibv_moderate_cq,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
pub const IBV_FLOW_ATTR_FLAGS_DONT_TRAP: ibv_flow_flags = 2;
pub const IBV_FLOW_ATTR_FLAGS_EGRESS: ibv_flow_flags = 4;
pub type ibv_flow_flags = ::std::os::raw::c_uint;
pub const IBV_FLOW_ATTR_NORMAL: ibv_flow_attr_type = 0;
pub const IBV_FLOW_ATTR_ALL_DEFAULT: ibv_flow_attr_type = 1;
pub const IBV_FLOW_ATTR_MC_DEFAULT: ibv_flow_attr_type = 2;
pub const IBV_FLOW_ATTR_SNIFFER: ibv_flow_attr_type = 3;
pub type ibv_flow_attr_type = ::std::os::raw::c_uint;
pub const IBV_FLOW_SPEC_ETH: ibv_flow_spec_type = 32;
pub const IBV_FLOW_SPEC_IPV4: ibv_flow_spec_type = 48;
pub const IBV_FLOW_SPEC_IPV6: ibv_flow_spec_type = 49;
pub const IBV_FLOW_SPEC_IPV4_EXT: ibv_flow_spec_type = 50;
pub const IBV_FLOW_SPEC_ESP: ibv_flow_spec_type = 52;
pub const IBV_FLOW_SPEC_TCP: ibv_flow_spec_type = 64;
pub const IBV_FLOW_SPEC_UDP: ibv_flow_spec_type = 65;
pub const IBV_FLOW_SPEC_VXLAN_TUNNEL: ibv_flow_spec_type = 80;
pub const IBV_FLOW_SPEC_GRE: ibv_flow_spec_type = 81;
pub const IBV_FLOW_SPEC_MPLS: ibv_flow_spec_type = 96;
pub const IBV_FLOW_SPEC_INNER: ibv_flow_spec_type = 256;
pub const IBV_FLOW_SPEC_ACTION_TAG: ibv_flow_spec_type = 4096;
pub const IBV_FLOW_SPEC_ACTION_DROP: ibv_flow_spec_type = 4097;
pub const IBV_FLOW_SPEC_ACTION_HANDLE: ibv_flow_spec_type = 4098;
pub const IBV_FLOW_SPEC_ACTION_COUNT: ibv_flow_spec_type = 4099;
pub type ibv_flow_spec_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_eth_filter {
    pub dst_mac: [u8; 6usize],
    pub src_mac: [u8; 6usize],
    pub ether_type: u16,
    pub vlan_tag: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_eth {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_eth_filter,
    pub mask: ibv_flow_eth_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_ipv4_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_filter,
    pub mask: ibv_flow_ipv4_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_ipv4_ext_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4_ext {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_ext_filter,
    pub mask: ibv_flow_ipv4_ext_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_ipv6_filter {
    pub src_ip: [u8; 16usize],
    pub dst_ip: [u8; 16usize],
    pub flow_label: u32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv6 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv6_filter,
    pub mask: ibv_flow_ipv6_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_esp {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_esp_filter,
    pub mask: ibv_flow_esp_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_tcp_udp_filter {
    pub dst_port: u16,
    pub src_port: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tcp_udp {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tcp_udp_filter,
    pub mask: ibv_flow_tcp_udp_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_gre_filter {
    pub c_ks_res0_ver: u16,
    pub protocol: u16,
    pub key: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_gre {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_gre_filter,
    pub mask: ibv_flow_gre_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_mpls_filter {
    pub label: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_mpls {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_mpls_filter,
    pub mask: ibv_flow_mpls_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_tunnel_filter {
    pub tunnel_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tunnel {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tunnel_filter,
    pub mask: ibv_flow_tunnel_filter,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_tag {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub tag_id: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_drop {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_handle {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub action: *const ibv_flow_action,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_counter_action {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
    pub counters: *mut ibv_counters,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec {
    pub __bindgen_anon_1: ibv_flow_spec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_flow_spec__bindgen_ty_1 {
    pub hdr: ibv_flow_spec__bindgen_ty_1__bindgen_ty_1,
    pub eth: ibv_flow_spec_eth,
    pub ipv4: ibv_flow_spec_ipv4,
    pub tcp_udp: ibv_flow_spec_tcp_udp,
    pub ipv4_ext: ibv_flow_spec_ipv4_ext,
    pub ipv6: ibv_flow_spec_ipv6,
    pub esp: ibv_flow_spec_esp,
    pub tunnel: ibv_flow_spec_tunnel,
    pub gre: ibv_flow_spec_gre,
    pub mpls: ibv_flow_spec_mpls,
    pub flow_tag: ibv_flow_spec_action_tag,
    pub drop: ibv_flow_spec_action_drop,
    pub handle: ibv_flow_spec_action_handle,
    pub flow_count: ibv_flow_spec_counter_action,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    pub type_: ibv_flow_spec_type,
    pub size: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub type_: ibv_flow_attr_type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action {
    pub context: *mut ibv_context,
}
pub const IBV_FLOW_ACTION_ESP_MASK_ESN: ibv_flow_action_esp_mask = 1;
pub type ibv_flow_action_esp_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action_esp_attr {
    pub esp_attr: *mut ib_uverbs_flow_action_esp,
    pub keymat_proto: ib_uverbs_flow_action_esp_keymat,
    pub keymat_len: u16,
    pub keymat_ptr: *mut ::std::os::raw::c_void,
    pub replay_proto: ib_uverbs_flow_action_esp_replay,
    pub replay_len: u16,
    pub replay_ptr: *mut ::std::os::raw::c_void,
    pub esp_encap: *mut ib_uverbs_flow_action_esp_encap,
    pub comp_mask: u32,
    pub esn: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
pub const IBV_SYSFS_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const IBV_SYSFS_PATH_MAX: ::std::os::raw::c_uint = 256;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            device_attr: *mut ibv_device_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[repr(C)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
pub const IBV_CQ_INIT_ATTR_MASK_FLAGS: ibv_cq_init_attr_mask = 1;
pub const IBV_CQ_INIT_ATTR_MASK_PD: ibv_cq_init_attr_mask = 2;
pub type ibv_cq_init_attr_mask = ::std::os::raw::c_uint;
pub const IBV_CREATE_CQ_ATTR_SINGLE_THREADED: ibv_create_cq_attr_flags = 1;
pub const IBV_CREATE_CQ_ATTR_IGNORE_OVERRUN: ibv_create_cq_attr_flags = 2;
pub type ibv_create_cq_attr_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
    pub parent_domain: *mut ibv_pd,
}
pub const IBV_PARENT_DOMAIN_INIT_ATTR_ALLOCATORS: ibv_parent_domain_init_attr_mask = 1;
pub const IBV_PARENT_DOMAIN_INIT_ATTR_PD_CONTEXT: ibv_parent_domain_init_attr_mask = 2;
pub type ibv_parent_domain_init_attr_mask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_parent_domain_init_attr {
    pub pd: *mut ibv_pd,
    pub td: *mut ibv_td,
    pub comp_mask: u32,
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            size: usize,
            alignment: usize,
            resource_type: u64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            resource_type: u64,
        ),
    >,
    pub pd_context: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_counters_init_attr {
    pub comp_mask: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_counters {
    pub context: *mut ibv_context,
}
pub const IBV_COUNTER_PACKETS: ibv_counter_description = 0;
pub const IBV_COUNTER_BYTES: ibv_counter_description = 1;
pub type ibv_counter_description = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_counter_attach_attr {
    pub counter_desc: ibv_counter_description,
    pub index: u32,
    pub comp_mask: u32,
}
pub const IBV_READ_COUNTERS_ATTR_PREFER_CACHED: ibv_read_counters_flags = 1;
pub type ibv_read_counters_flags = ::std::os::raw::c_uint;
pub const IBV_VALUES_MASK_RAW_CLOCK: ibv_values_mask = 1;
pub const IBV_VALUES_MASK_RESERVED: ibv_values_mask = 2;
pub type ibv_values_mask = ::std::os::raw::c_uint;
#[repr(C)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: timespec,
}
#[repr(C)]
pub struct verbs_context {
    pub query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut ibv_port_attr,
            port_attr_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub advise_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            advice: ib_uverbs_advise_mr_advice,
            flags: u32,
            sg_list: *mut ibv_sge,
            num_sges: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub alloc_null_mr: ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> *mut ibv_mr>,
    pub read_counters: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            counters_value: *mut u64,
            ncounters: u32,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub attach_counters_point_flow: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            attr: *mut ibv_counter_attach_attr,
            flow: *mut ibv_flow,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_counters: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_counters_init_attr,
        ) -> *mut ibv_counters,
    >,
    pub destroy_counters: ::std::option::Option<
        unsafe extern "C" fn(counters: *mut ibv_counters) -> ::std::os::raw::c_int,
    >,
    pub reg_dm_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
            access: ::std::os::raw::c_uint,
        ) -> *mut ibv_mr,
    >,
    pub alloc_dm: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_alloc_dm_attr,
        ) -> *mut ibv_dm,
    >,
    pub free_dm:
        ::std::option::Option<unsafe extern "C" fn(dm: *mut ibv_dm) -> ::std::os::raw::c_int>,
    pub modify_flow_action_esp: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut ibv_flow_action,
            attr: *mut ibv_flow_action_esp_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_flow_action: ::std::option::Option<
        unsafe extern "C" fn(action: *mut ibv_flow_action) -> ::std::os::raw::c_int,
    >,
    pub create_flow_action_esp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_flow_action_esp_attr,
        ) -> *mut ibv_flow_action,
    >,
    pub modify_qp_rate_limit: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            attr: *mut ibv_qp_rate_limit_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub alloc_parent_domain: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_parent_domain_init_attr,
        ) -> *mut ibv_pd,
    >,
    pub dealloc_td:
        ::std::option::Option<unsafe extern "C" fn(td: *mut ibv_td) -> ::std::os::raw::c_int>,
    pub alloc_td: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_td_init_attr,
        ) -> *mut ibv_td,
    >,
    pub modify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            attr: *mut ibv_modify_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_srq_ops: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            op: *mut ibv_ops_wr,
            bad_op: *mut *mut ibv_ops_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(rwq_ind_table: *mut ibv_rwq_ind_table) -> ::std::os::raw::c_int,
    >,
    pub create_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_rwq_ind_table_init_attr,
        ) -> *mut ibv_rwq_ind_table,
    >,
    pub destroy_wq:
        ::std::option::Option<unsafe extern "C" fn(wq: *mut ibv_wq) -> ::std::os::raw::c_int>,
    pub modify_wq: ::std::option::Option<
        unsafe extern "C" fn(wq: *mut ibv_wq, wq_attr: *mut ibv_wq_attr) -> ::std::os::raw::c_int,
    >,
    pub create_wq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            wq_init_attr: *mut ibv_wq_init_attr,
        ) -> *mut ibv_wq,
    >,
    pub query_rt_values: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            values: *mut ibv_values_ex,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_cq_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_cq_init_attr_ex,
        ) -> *mut ibv_cq_ex,
    >,
    pub priv_: *mut verbs_ex_private,
    pub query_device_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            input: *const ibv_query_device_ex_input,
            attr: *mut ibv_device_attr_ex,
            attr_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub ibv_destroy_flow:
        ::std::option::Option<unsafe extern "C" fn(flow: *mut ibv_flow) -> ::std::os::raw::c_int>,
    pub ABI_placeholder2: ::std::option::Option<unsafe extern "C" fn()>,
    pub ibv_create_flow: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp, flow_attr: *mut ibv_flow_attr) -> *mut ibv_flow,
    >,
    pub ABI_placeholder1: ::std::option::Option<unsafe extern "C" fn()>,
    pub open_qp: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context, attr: *mut ibv_qp_open_attr) -> *mut ibv_qp,
    >,
    pub create_qp_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            qp_init_attr_ex: *mut ibv_qp_init_attr_ex,
        ) -> *mut ibv_qp,
    >,
    pub get_srq_num: ::std::option::Option<
        unsafe extern "C" fn(srq: *mut ibv_srq, srq_num: *mut u32) -> ::std::os::raw::c_int,
    >,
    pub create_srq_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            srq_init_attr_ex: *mut ibv_srq_init_attr_ex,
        ) -> *mut ibv_srq,
    >,
    pub open_xrcd: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            xrcd_init_attr: *mut ibv_xrcd_init_attr,
        ) -> *mut ibv_xrcd,
    >,
    pub close_xrcd:
        ::std::option::Option<unsafe extern "C" fn(xrcd: *mut ibv_xrcd) -> ::std::os::raw::c_int>,
    pub _ABI_placeholder3: u64,
    pub sz: usize,
    pub context: ibv_context,
}
extern "C" {
    #[doc = " ibv_get_device_list - Get list of IB devices currently available"]
    #[doc = " @num_devices: optional.  if non-NULL, set to the number of devices"]
    #[doc = " returned in the array."]
    #[doc = ""]
    #[doc = " Return a NULL-terminated array of IB devices.  The array can be"]
    #[doc = " released with ibv_free_device_list()."]
    pub fn ibv_get_device_list(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_device;
}
extern "C" {
    #[doc = " ibv_free_device_list - Free list from ibv_get_device_list()"]
    #[doc = ""]
    #[doc = " Free an array of devices returned from ibv_get_device_list().  Once"]
    #[doc = " the array is freed, pointers to devices that were not opened with"]
    #[doc = " ibv_open_device() are no longer valid.  Client code must open all"]
    #[doc = " devices it intends to use before calling ibv_free_device_list()."]
    pub fn ibv_free_device_list(list: *mut *mut ibv_device);
}
extern "C" {
    #[doc = " ibv_get_device_name - Return kernel device name"]
    pub fn ibv_get_device_name(device: *mut ibv_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_get_device_index - Return kernel device index"]
    #[doc = ""]
    #[doc = " Available for the kernel with support of IB device query"]
    #[doc = " over netlink interface. For the unsupported kernels, the"]
    #[doc = " relevant -1 will be returned."]
    pub fn ibv_get_device_index(device: *mut ibv_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_device_guid - Return device's node GUID"]
    pub fn ibv_get_device_guid(device: *mut ibv_device) -> __be64;
}
extern "C" {
    #[doc = " ibv_open_device - Initialize device for use"]
    pub fn ibv_open_device(device: *mut ibv_device) -> *mut ibv_context;
}
extern "C" {
    #[doc = " ibv_close_device - Release device"]
    pub fn ibv_close_device(context: *mut ibv_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_import_device - Import device"]
    pub fn ibv_import_device(cmd_fd: ::std::os::raw::c_int) -> *mut ibv_context;
}
extern "C" {
    #[doc = " ibv_import_pd - Import a protetion domain"]
    pub fn ibv_import_pd(context: *mut ibv_context, pd_handle: u32) -> *mut ibv_pd;
}
extern "C" {
    #[doc = " ibv_unimport_pd - Unimport a protetion domain"]
    pub fn ibv_unimport_pd(pd: *mut ibv_pd);
}
extern "C" {
    #[doc = " ibv_import_mr - Import a memory region"]
    pub fn ibv_import_mr(pd: *mut ibv_pd, mr_handle: u32) -> *mut ibv_mr;
}
extern "C" {
    #[doc = " ibv_unimport_mr - Unimport a memory region"]
    pub fn ibv_unimport_mr(mr: *mut ibv_mr);
}
extern "C" {
    #[doc = " ibv_import_dm - Import a device memory"]
    pub fn ibv_import_dm(context: *mut ibv_context, dm_handle: u32) -> *mut ibv_dm;
}
extern "C" {
    #[doc = " ibv_unimport_dm - Unimport a device memory"]
    pub fn ibv_unimport_dm(dm: *mut ibv_dm);
}
extern "C" {
    #[doc = " ibv_get_async_event - Get next async event"]
    #[doc = " @event: Pointer to use to return async event"]
    #[doc = ""]
    #[doc = " All async events returned by ibv_get_async_event() must eventually"]
    #[doc = " be acknowledged with ibv_ack_async_event()."]
    pub fn ibv_get_async_event(
        context: *mut ibv_context,
        event: *mut ibv_async_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_ack_async_event - Acknowledge an async event"]
    #[doc = " @event: Event to be acknowledged."]
    #[doc = ""]
    #[doc = " All async events which are returned by ibv_get_async_event() must"]
    #[doc = " be acknowledged.  To avoid races, destroying an object (CQ, SRQ or"]
    #[doc = " QP) will wait for all affiliated events to be acknowledged, so"]
    #[doc = " there should be a one-to-one correspondence between acks and"]
    #[doc = " successful gets."]
    pub fn ibv_ack_async_event(event: *mut ibv_async_event);
}
extern "C" {
    #[doc = " ibv_query_device - Get device properties"]
    pub fn ibv_query_device(
        context: *mut ibv_context,
        device_attr: *mut ibv_device_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_gid - Get a GID table entry"]
    pub fn ibv_query_gid(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        gid: *mut ibv_gid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ibv_query_gid_ex(
        context: *mut ibv_context,
        port_num: u32,
        gid_index: u32,
        entry: *mut ibv_gid_entry,
        flags: u32,
        entry_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_pkey - Get a P_Key table entry"]
    pub fn ibv_query_pkey(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        pkey: *mut __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_pkey_index - Translate a P_Key into a P_Key index"]
    pub fn ibv_get_pkey_index(
        context: *mut ibv_context,
        port_num: u8,
        pkey: __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_alloc_pd - Allocate a protection domain"]
    pub fn ibv_alloc_pd(context: *mut ibv_context) -> *mut ibv_pd;
}
extern "C" {
    #[doc = " ibv_dealloc_pd - Free a protection domain"]
    pub fn ibv_dealloc_pd(pd: *mut ibv_pd) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_reg_mr_iova2 - Register memory region with a virtual offset address"]
    #[doc = ""]
    #[doc = " This version will be called if ibv_reg_mr or ibv_reg_mr_iova were called"]
    #[doc = " with at least one potential access flag from the IBV_OPTIONAL_ACCESS_RANGE"]
    #[doc = " flags range The optional access flags will be masked if running over kernel"]
    #[doc = " that does not support passing them."]
    pub fn ibv_reg_mr_iova2(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        iova: u64,
        access: ::std::os::raw::c_uint,
    ) -> *mut ibv_mr;
}
extern "C" {
    #[doc = " ibv_reg_mr_iova - Register a memory region with a virtual offset"]
    #[doc = " address"]
    pub fn ibv_reg_mr_iova(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        iova: u64,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
extern "C" {
    #[doc = " ibv_reg_dmabuf_mr - Register a dambuf-based memory region"]
    pub fn ibv_reg_dmabuf_mr(
        pd: *mut ibv_pd,
        offset: u64,
        length: usize,
        iova: u64,
        fd: ::std::os::raw::c_int,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
pub const IBV_REREG_MR_ERR_INPUT: ibv_rereg_mr_err_code = -1;
pub const IBV_REREG_MR_ERR_DONT_FORK_NEW: ibv_rereg_mr_err_code = -2;
pub const IBV_REREG_MR_ERR_DO_FORK_OLD: ibv_rereg_mr_err_code = -3;
pub const IBV_REREG_MR_ERR_CMD: ibv_rereg_mr_err_code = -4;
pub const IBV_REREG_MR_ERR_CMD_AND_DO_FORK_NEW: ibv_rereg_mr_err_code = -5;
pub type ibv_rereg_mr_err_code = ::std::os::raw::c_int;
extern "C" {
    #[doc = " ibv_rereg_mr - Re-Register a memory region"]
    pub fn ibv_rereg_mr(
        mr: *mut ibv_mr,
        flags: ::std::os::raw::c_int,
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        access: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_dereg_mr - Deregister a memory region"]
    pub fn ibv_dereg_mr(mr: *mut ibv_mr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_comp_channel - Create a completion event channel"]
    pub fn ibv_create_comp_channel(context: *mut ibv_context) -> *mut ibv_comp_channel;
}
extern "C" {
    #[doc = " ibv_destroy_comp_channel - Destroy a completion event channel"]
    pub fn ibv_destroy_comp_channel(channel: *mut ibv_comp_channel) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_cq - Create a completion queue"]
    #[doc = " @context - Context CQ will be attached to"]
    #[doc = " @cqe - Minimum number of entries required for CQ"]
    #[doc = " @cq_context - Consumer-supplied context returned for completion events"]
    #[doc = " @channel - Completion channel where completion events will be queued."]
    #[doc = "     May be NULL if completion events will not be used."]
    #[doc = " @comp_vector - Completion vector used to signal completion events."]
    #[doc = "     Must be >= 0 and < context->num_comp_vectors."]
    pub fn ibv_create_cq(
        context: *mut ibv_context,
        cqe: ::std::os::raw::c_int,
        cq_context: *mut ::std::os::raw::c_void,
        channel: *mut ibv_comp_channel,
        comp_vector: ::std::os::raw::c_int,
    ) -> *mut ibv_cq;
}
extern "C" {
    #[doc = " ibv_resize_cq - Modifies the capacity of the CQ."]
    #[doc = " @cq: The CQ to resize."]
    #[doc = " @cqe: The minimum size of the CQ."]
    #[doc = ""]
    #[doc = " Users can examine the cq structure to determine the actual CQ size."]
    pub fn ibv_resize_cq(cq: *mut ibv_cq, cqe: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_cq - Destroy a completion queue"]
    pub fn ibv_destroy_cq(cq: *mut ibv_cq) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_cq_event - Read next CQ event"]
    #[doc = " @channel: Channel to get next event from."]
    #[doc = " @cq: Used to return pointer to CQ."]
    #[doc = " @cq_context: Used to return consumer-supplied CQ context."]
    #[doc = ""]
    #[doc = " All completion events returned by ibv_get_cq_event() must"]
    #[doc = " eventually be acknowledged with ibv_ack_cq_events()."]
    pub fn ibv_get_cq_event(
        channel: *mut ibv_comp_channel,
        cq: *mut *mut ibv_cq,
        cq_context: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_ack_cq_events - Acknowledge CQ completion events"]
    #[doc = " @cq: CQ to acknowledge events for"]
    #[doc = " @nevents: Number of events to acknowledge."]
    #[doc = ""]
    #[doc = " All completion events which are returned by ibv_get_cq_event() must"]
    #[doc = " be acknowledged.  To avoid races, ibv_destroy_cq() will wait for"]
    #[doc = " all completion events to be acknowledged, so there should be a"]
    #[doc = " one-to-one correspondence between acks and successful gets.  An"]
    #[doc = " application may accumulate multiple completion events and"]
    #[doc = " acknowledge them in a single call to ibv_ack_cq_events() by passing"]
    #[doc = " the number of events to ack in @nevents."]
    pub fn ibv_ack_cq_events(cq: *mut ibv_cq, nevents: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " ibv_create_srq - Creates a SRQ associated with the specified protection"]
    #[doc = "   domain."]
    #[doc = " @pd: The protection domain associated with the SRQ."]
    #[doc = " @srq_init_attr: A list of initial attributes required to create the SRQ."]
    #[doc = ""]
    #[doc = " srq_attr->max_wr and srq_attr->max_sge are read the determine the"]
    #[doc = " requested size of the SRQ, and set to the actual values allocated"]
    #[doc = " on return.  If ibv_create_srq() succeeds, then max_wr and max_sge"]
    #[doc = " will always be at least as large as the requested values."]
    pub fn ibv_create_srq(pd: *mut ibv_pd, srq_init_attr: *mut ibv_srq_init_attr) -> *mut ibv_srq;
}
extern "C" {
    #[doc = " ibv_modify_srq - Modifies the attributes for the specified SRQ."]
    #[doc = " @srq: The SRQ to modify."]
    #[doc = " @srq_attr: On input, specifies the SRQ attributes to modify.  On output,"]
    #[doc = "   the current values of selected SRQ attributes are returned."]
    #[doc = " @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ"]
    #[doc = "   are being modified."]
    #[doc = ""]
    #[doc = " The mask may contain IBV_SRQ_MAX_WR to resize the SRQ and/or"]
    #[doc = " IBV_SRQ_LIMIT to set the SRQ's limit and request notification when"]
    #[doc = " the number of receives queued drops below the limit."]
    pub fn ibv_modify_srq(
        srq: *mut ibv_srq,
        srq_attr: *mut ibv_srq_attr,
        srq_attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_srq - Returns the attribute list and current values for the"]
    #[doc = "   specified SRQ."]
    #[doc = " @srq: The SRQ to query."]
    #[doc = " @srq_attr: The attributes of the specified SRQ."]
    pub fn ibv_query_srq(srq: *mut ibv_srq, srq_attr: *mut ibv_srq_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_srq - Destroys the specified SRQ."]
    #[doc = " @srq: The SRQ to destroy."]
    pub fn ibv_destroy_srq(srq: *mut ibv_srq) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_qp - Create a queue pair."]
    pub fn ibv_create_qp(pd: *mut ibv_pd, qp_init_attr: *mut ibv_qp_init_attr) -> *mut ibv_qp;
}
extern "C" {
    #[doc = " ibv_modify_qp - Modify a queue pair."]
    pub fn ibv_modify_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_qp_data_in_order - Checks whether the data is guaranteed to be"]
    #[doc = "   written in-order."]
    #[doc = " @qp: The QP to query."]
    #[doc = " @op: Operation type."]
    #[doc = " @flags: Extra field for future input. For now must be 0."]
    #[doc = ""]
    #[doc = " Return Value"]
    #[doc = " ibv_query_qp_data_in_order() returns 1 if the data is guaranteed to be"]
    #[doc = "   written in-order, 0 otherwise."]
    pub fn ibv_query_qp_data_in_order(
        qp: *mut ibv_qp,
        op: ibv_wr_opcode,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_qp - Returns the attribute list and current values for the"]
    #[doc = "   specified QP."]
    #[doc = " @qp: The QP to query."]
    #[doc = " @attr: The attributes of the specified QP."]
    #[doc = " @attr_mask: A bit-mask used to select specific attributes to query."]
    #[doc = " @init_attr: Additional attributes of the selected QP."]
    #[doc = ""]
    #[doc = " The qp_attr_mask may be used to limit the query to gathering only the"]
    #[doc = " selected attributes."]
    pub fn ibv_query_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
        init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_qp - Destroy a queue pair."]
    pub fn ibv_destroy_qp(qp: *mut ibv_qp) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_ah - Create an address handle."]
    pub fn ibv_create_ah(pd: *mut ibv_pd, attr: *mut ibv_ah_attr) -> *mut ibv_ah;
}
extern "C" {
    #[doc = " ibv_init_ah_from_wc - Initializes address handle attributes from a"]
    #[doc = "   work completion."]
    #[doc = " @context: Device context on which the received message arrived."]
    #[doc = " @port_num: Port on which the received message arrived."]
    #[doc = " @wc: Work completion associated with the received message."]
    #[doc = " @grh: References the received global route header.  This parameter is"]
    #[doc = "   ignored unless the work completion indicates that the GRH is valid."]
    #[doc = " @ah_attr: Returned attributes that can be used when creating an address"]
    #[doc = "   handle for replying to the message."]
    pub fn ibv_init_ah_from_wc(
        context: *mut ibv_context,
        port_num: u8,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        ah_attr: *mut ibv_ah_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_ah_from_wc - Creates an address handle associated with the"]
    #[doc = "   sender of the specified work completion."]
    #[doc = " @pd: The protection domain associated with the address handle."]
    #[doc = " @wc: Work completion information associated with a received message."]
    #[doc = " @grh: References the received global route header.  This parameter is"]
    #[doc = "   ignored unless the work completion indicates that the GRH is valid."]
    #[doc = " @port_num: The outbound port number to associate with the address."]
    #[doc = ""]
    #[doc = " The address handle is used to reference a local or global destination"]
    #[doc = " in all UD QP post sends."]
    pub fn ibv_create_ah_from_wc(
        pd: *mut ibv_pd,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        port_num: u8,
    ) -> *mut ibv_ah;
}
extern "C" {
    #[doc = " ibv_destroy_ah - Destroy an address handle."]
    pub fn ibv_destroy_ah(ah: *mut ibv_ah) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_attach_mcast - Attaches the specified QP to a multicast group."]
    #[doc = " @qp: QP to attach to the multicast group.  The QP must be a UD QP."]
    #[doc = " @gid: Multicast group GID."]
    #[doc = " @lid: Multicast group LID in host byte order."]
    #[doc = ""]
    #[doc = " In order to route multicast packets correctly, subnet"]
    #[doc = " administration must have created the multicast group and configured"]
    #[doc = " the fabric appropriately.  The port associated with the specified"]
    #[doc = " QP must also be a member of the multicast group."]
    pub fn ibv_attach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_detach_mcast - Detaches the specified QP from a multicast group."]
    #[doc = " @qp: QP to detach from the multicast group."]
    #[doc = " @gid: Multicast group GID."]
    #[doc = " @lid: Multicast group LID in host byte order."]
    pub fn ibv_detach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_fork_init - Prepare data structures so that fork() may be used"]
    #[doc = " safely.  If this function is not called or returns a non-zero"]
    #[doc = " status, then libibverbs data structures are not fork()-safe and the"]
    #[doc = " effect of an application calling fork() is undefined."]
    pub fn ibv_fork_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_is_fork_initialized - Check if fork support"]
    #[doc = " (ibv_fork_init) was enabled."]
    pub fn ibv_is_fork_initialized() -> ibv_fork_status;
}
extern "C" {
    #[doc = " ibv_node_type_str - Return string describing node_type enum value"]
    pub fn ibv_node_type_str(node_type: ibv_node_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_port_state_str - Return string describing port_state enum value"]
    pub fn ibv_port_state_str(port_state: ibv_port_state) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_event_type_str - Return string describing event_type enum value"]
    pub fn ibv_event_type_str(event: ibv_event_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_resolve_eth_l2_from_gid(
        context: *mut ibv_context,
        attr: *mut ibv_ah_attr,
        eth_mac: *mut u8,
        vid: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_set_ece - Set ECE options"]
    pub fn ibv_set_ece(qp: *mut ibv_qp, ece: *mut ibv_ece) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_ece - Get accepted ECE options"]
    pub fn ibv_query_ece(qp: *mut ibv_qp, ece: *mut ibv_ece) -> ::std::os::raw::c_int;
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_path_rec {
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub raw_traffic: ::std::os::raw::c_int,
    pub flow_label: __be32,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reversible: ::std::os::raw::c_int,
    pub numb_path: u8,
    pub pkey: __be16,
    pub sl: u8,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub preference: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_mcmember_rec {
    pub mgid: ibv_gid,
    pub port_gid: ibv_gid,
    pub qkey: u32,
    pub mlid: u16,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub traffic_class: u8,
    pub pkey: u16,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub sl: u8,
    pub flow_label: u32,
    pub hop_limit: u8,
    pub scope: u8,
    pub join_state: u8,
    pub proxy_join: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_service_rec {
    pub id: u64,
    pub gid: ibv_gid,
    pub pkey: u16,
    pub lease: u32,
    pub key: [u8; 16usize],
    pub name: [u8; 64usize],
    pub data8: [u8; 16usize],
    pub data16: [u16; 8usize],
    pub data32: [u32; 4usize],
    pub data64: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_record {
    pub service_id: __be64,
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub flowlabel_hoplimit: __be32,
    pub tclass: u8,
    pub reversible_numpath: u8,
    pub pkey: __be16,
    pub qosclass_sl: __be16,
    pub mtu: u8,
    pub rate: u8,
    pub packetlifetime: u8,
    pub preference: u8,
    pub reserved: [u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_data {
    pub flags: u32,
    pub reserved: u32,
    pub path: ibv_path_record,
}
pub const RDMA_CM_EVENT_ADDR_RESOLVED: rdma_cm_event_type = 0;
pub const RDMA_CM_EVENT_ADDR_ERROR: rdma_cm_event_type = 1;
pub const RDMA_CM_EVENT_ROUTE_RESOLVED: rdma_cm_event_type = 2;
pub const RDMA_CM_EVENT_ROUTE_ERROR: rdma_cm_event_type = 3;
pub const RDMA_CM_EVENT_CONNECT_REQUEST: rdma_cm_event_type = 4;
pub const RDMA_CM_EVENT_CONNECT_RESPONSE: rdma_cm_event_type = 5;
pub const RDMA_CM_EVENT_CONNECT_ERROR: rdma_cm_event_type = 6;
pub const RDMA_CM_EVENT_UNREACHABLE: rdma_cm_event_type = 7;
pub const RDMA_CM_EVENT_REJECTED: rdma_cm_event_type = 8;
pub const RDMA_CM_EVENT_ESTABLISHED: rdma_cm_event_type = 9;
pub const RDMA_CM_EVENT_DISCONNECTED: rdma_cm_event_type = 10;
pub const RDMA_CM_EVENT_DEVICE_REMOVAL: rdma_cm_event_type = 11;
pub const RDMA_CM_EVENT_MULTICAST_JOIN: rdma_cm_event_type = 12;
pub const RDMA_CM_EVENT_MULTICAST_ERROR: rdma_cm_event_type = 13;
pub const RDMA_CM_EVENT_ADDR_CHANGE: rdma_cm_event_type = 14;
pub const RDMA_CM_EVENT_TIMEWAIT_EXIT: rdma_cm_event_type = 15;
pub type rdma_cm_event_type = ::std::os::raw::c_uint;
pub const RDMA_PS_IPOIB: rdma_port_space = 2;
pub const RDMA_PS_TCP: rdma_port_space = 262;
pub const RDMA_PS_UDP: rdma_port_space = 273;
pub const RDMA_PS_IB: rdma_port_space = 319;
pub type rdma_port_space = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ib_addr {
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
    pub pkey: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_addr {
    pub __bindgen_anon_1: rdma_addr__bindgen_ty_1,
    pub __bindgen_anon_2: rdma_addr__bindgen_ty_2,
    pub addr: rdma_addr__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_1 {
    pub src_addr: sockaddr,
    pub src_sin: sockaddr_in,
    pub src_sin6: sockaddr_in6,
    pub src_storage: sockaddr_storage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_2 {
    pub dst_addr: sockaddr,
    pub dst_sin: sockaddr_in,
    pub dst_sin6: sockaddr_in6,
    pub dst_storage: sockaddr_storage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_3 {
    pub ibaddr: rdma_ib_addr,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_route {
    pub addr: rdma_addr,
    pub path_rec: *mut ibv_sa_path_rec,
    pub num_paths: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_event_channel {
    pub fd: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_id {
    pub verbs: *mut ibv_context,
    pub channel: *mut rdma_event_channel,
    pub context: *mut ::std::os::raw::c_void,
    pub qp: *mut ibv_qp,
    pub route: rdma_route,
    pub ps: rdma_port_space,
    pub port_num: u8,
    pub event: *mut rdma_cm_event,
    pub send_cq_channel: *mut ibv_comp_channel,
    pub send_cq: *mut ibv_cq,
    pub recv_cq_channel: *mut ibv_comp_channel,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub pd: *mut ibv_pd,
    pub qp_type: ibv_qp_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_conn_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub responder_resources: u8,
    pub initiator_depth: u8,
    pub flow_control: u8,
    pub retry_count: u8,
    pub rnr_retry_count: u8,
    pub srq: u8,
    pub qp_num: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ud_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub ah_attr: ibv_ah_attr,
    pub qp_num: u32,
    pub qkey: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_event {
    pub id: *mut rdma_cm_id,
    pub listen_id: *mut rdma_cm_id,
    pub event: rdma_cm_event_type,
    pub status: ::std::os::raw::c_int,
    pub param: rdma_cm_event__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_cm_event__bindgen_ty_1 {
    pub conn: rdma_conn_param,
    pub ud: rdma_ud_param,
}
#[repr(C)]
pub struct rdma_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_qp_type: ::std::os::raw::c_int,
    pub ai_port_space: ::std::os::raw::c_int,
    pub ai_src_len: socklen_t,
    pub ai_dst_len: socklen_t,
    pub ai_src_addr: *mut sockaddr,
    pub ai_dst_addr: *mut sockaddr,
    pub ai_src_canonname: *mut ::std::os::raw::c_char,
    pub ai_dst_canonname: *mut ::std::os::raw::c_char,
    pub ai_route_len: usize,
    pub ai_route: *mut ::std::os::raw::c_void,
    pub ai_connect_len: usize,
    pub ai_connect: *mut ::std::os::raw::c_void,
    pub ai_next: *mut rdma_addrinfo,
}
pub const RDMA_CM_JOIN_MC_ATTR_ADDRESS: rdma_cm_join_mc_attr_mask = 1;
pub const RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS: rdma_cm_join_mc_attr_mask = 2;
pub const RDMA_CM_JOIN_MC_ATTR_RESERVED: rdma_cm_join_mc_attr_mask = 4;
pub type rdma_cm_join_mc_attr_mask = ::std::os::raw::c_uint;
pub const RDMA_MC_JOIN_FLAG_FULLMEMBER: rdma_cm_mc_join_flags = 0;
pub const RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER: rdma_cm_mc_join_flags = 1;
pub const RDMA_MC_JOIN_FLAG_RESERVED: rdma_cm_mc_join_flags = 2;
pub type rdma_cm_mc_join_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_cm_join_mc_attr_ex {
    pub comp_mask: u32,
    pub join_flags: u32,
    pub addr: *mut sockaddr,
}
extern "C" {
    #[doc = " rdma_create_event_channel - Open a channel used to report communication events."]
    #[doc = " Description:"]
    #[doc = "   Asynchronous events are reported to users through event channels.  Each"]
    #[doc = "   event channel maps to a file descriptor."]
    #[doc = " Notes:"]
    #[doc = "   All created event channels must be destroyed by calling"]
    #[doc = "   rdma_destroy_event_channel.  Users should call rdma_get_cm_event to"]
    #[doc = "   retrieve events on an event channel."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event, rdma_destroy_event_channel"]
    pub fn rdma_create_event_channel() -> *mut rdma_event_channel;
}
extern "C" {
    #[doc = " rdma_destroy_event_channel - Close an event communication channel."]
    #[doc = " @channel: The communication channel to destroy."]
    #[doc = " Description:"]
    #[doc = "   Release all resources associated with an event channel and closes the"]
    #[doc = "   associated file descriptor."]
    #[doc = " Notes:"]
    #[doc = "   All rdma_cm_id's associated with the event channel must be destroyed,"]
    #[doc = "   and all returned events must be acked before calling this function."]
    #[doc = " See also:"]
    #[doc = "  rdma_create_event_channel, rdma_get_cm_event, rdma_ack_cm_event"]
    pub fn rdma_destroy_event_channel(channel: *mut rdma_event_channel);
}
extern "C" {
    #[doc = " rdma_create_id - Allocate a communication identifier."]
    #[doc = " @channel: The communication channel that events associated with the"]
    #[doc = "   allocated rdma_cm_id will be reported on."]
    #[doc = " @id: A reference where the allocated communication identifier will be"]
    #[doc = "   returned."]
    #[doc = " @context: User specified context associated with the rdma_cm_id."]
    #[doc = " @ps: RDMA port space."]
    #[doc = " Description:"]
    #[doc = "   Creates an identifier that is used to track communication information."]
    #[doc = " Notes:"]
    #[doc = "   Rdma_cm_id's are conceptually equivalent to a socket for RDMA"]
    #[doc = "   communication.  The difference is that RDMA communication requires"]
    #[doc = "   explicitly binding to a specified RDMA device before communication"]
    #[doc = "   can occur, and most operations are asynchronous in nature.  Communication"]
    #[doc = "   events on an rdma_cm_id are reported through the associated event"]
    #[doc = "   channel.  Users must release the rdma_cm_id by calling rdma_destroy_id."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_event_channel, rdma_destroy_id, rdma_get_devices,"]
    #[doc = "   rdma_bind_addr, rdma_resolve_addr, rdma_connect, rdma_listen,"]
    pub fn rdma_create_id(
        channel: *mut rdma_event_channel,
        id: *mut *mut rdma_cm_id,
        context: *mut ::std::os::raw::c_void,
        ps: rdma_port_space,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_create_ep - Allocate a communication identifier and qp."]
    #[doc = " @id: A reference where the allocated communication identifier will be"]
    #[doc = "   returned."]
    #[doc = " @res: Result from rdma_getaddrinfo, which specifies the source and"]
    #[doc = "   destination addresses, plus optional routing and connection information."]
    #[doc = " @pd: Optional protection domain.  This parameter is ignored if qp_init_attr"]
    #[doc = "   is NULL."]
    #[doc = " @qp_init_attr: Optional attributes for a QP created on the rdma_cm_id."]
    #[doc = " Description:"]
    #[doc = "   Create an identifier and option QP used for communication."]
    #[doc = " Notes:"]
    #[doc = "   If qp_init_attr is provided, then a queue pair will be allocated and"]
    #[doc = "   associated with the rdma_cm_id.  If a pd is provided, the QP will be"]
    #[doc = "   created on that PD.  Otherwise, the QP will be allocated on a default"]
    #[doc = "   PD."]
    #[doc = "   The rdma_cm_id will be set to use synchronous operations (connect,"]
    #[doc = "   listen, and get_request).  To convert to asynchronous operation, the"]
    #[doc = "   rdma_cm_id should be migrated to a user allocated event channel."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_create_qp, rdma_migrate_id, rdma_connect,"]
    #[doc = "   rdma_listen"]
    pub fn rdma_create_ep(
        id: *mut *mut rdma_cm_id,
        res: *mut rdma_addrinfo,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_destroy_ep - Deallocates a communication identifier and qp."]
    #[doc = " @id: The communication identifier to destroy."]
    #[doc = " Description:"]
    #[doc = "   Destroys the specified rdma_cm_id and any associated QP created"]
    #[doc = "   on that id."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_ep"]
    pub fn rdma_destroy_ep(id: *mut rdma_cm_id);
}
extern "C" {
    #[doc = " rdma_destroy_id - Release a communication identifier."]
    #[doc = " @id: The communication identifier to destroy."]
    #[doc = " Description:"]
    #[doc = "   Destroys the specified rdma_cm_id and cancels any outstanding"]
    #[doc = "   asynchronous operation."]
    #[doc = " Notes:"]
    #[doc = "   Users must free any associated QP with the rdma_cm_id before"]
    #[doc = "   calling this routine and ack an related events."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_destroy_qp, rdma_ack_cm_event"]
    pub fn rdma_destroy_id(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_bind_addr - Bind an RDMA identifier to a source address."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @addr: Local address information.  Wildcard values are permitted."]
    #[doc = " Description:"]
    #[doc = "   Associates a source address with an rdma_cm_id.  The address may be"]
    #[doc = "   wildcarded.  If binding to a specific local address, the rdma_cm_id"]
    #[doc = "   will also be bound to a local RDMA device."]
    #[doc = " Notes:"]
    #[doc = "   Typically, this routine is called before calling rdma_listen to bind"]
    #[doc = "   to a specific port number, but it may also be called on the active side"]
    #[doc = "   of a connection before calling rdma_resolve_addr to bind to a specific"]
    #[doc = "   address."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_listen, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_bind_addr(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_resolve_addr - Resolve destination and optional source addresses."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @src_addr: Source address information.  This parameter may be NULL."]
    #[doc = " @dst_addr: Destination address information."]
    #[doc = " @timeout_ms: Time to wait for resolution to complete."]
    #[doc = " Description:"]
    #[doc = "   Resolve destination and optional source addresses from IP addresses"]
    #[doc = "   to an RDMA address.  If successful, the specified rdma_cm_id will"]
    #[doc = "   be bound to a local device."]
    #[doc = " Notes:"]
    #[doc = "   This call is used to map a given destination IP address to a usable RDMA"]
    #[doc = "   address.  If a source address is given, the rdma_cm_id is bound to that"]
    #[doc = "   address, the same as if rdma_bind_addr were called.  If no source"]
    #[doc = "   address is given, and the rdma_cm_id has not yet been bound to a device,"]
    #[doc = "   then the rdma_cm_id will be bound to a source address based on the"]
    #[doc = "   local routing tables.  After this call, the rdma_cm_id will be bound to"]
    #[doc = "   an RDMA device.  This call is typically made from the active side of a"]
    #[doc = "   connection before calling rdma_resolve_route and rdma_connect."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_resolve_route, rdma_connect, rdma_create_qp,"]
    #[doc = "   rdma_get_cm_event, rdma_bind_addr"]
    pub fn rdma_resolve_addr(
        id: *mut rdma_cm_id,
        src_addr: *mut sockaddr,
        dst_addr: *mut sockaddr,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_resolve_route - Resolve the route information needed to establish a connection."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @timeout_ms: Time to wait for resolution to complete."]
    #[doc = " Description:"]
    #[doc = "   Resolves an RDMA route to the destination address in order to establish"]
    #[doc = "   a connection.  The destination address must have already been resolved"]
    #[doc = "   by calling rdma_resolve_addr."]
    #[doc = " Notes:"]
    #[doc = "   This is called on the client side of a connection after calling"]
    #[doc = "   rdma_resolve_addr, but before calling rdma_connect."]
    #[doc = " See also:"]
    #[doc = "   rdma_resolve_addr, rdma_connect, rdma_get_cm_event"]
    pub fn rdma_resolve_route(
        id: *mut rdma_cm_id,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_create_qp - Allocate a QP."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @pd: Optional protection domain for the QP."]
    #[doc = " @qp_init_attr: initial QP attributes."]
    #[doc = " Description:"]
    #[doc = "  Allocate a QP associated with the specified rdma_cm_id and transition it"]
    #[doc = "  for sending and receiving."]
    #[doc = " Notes:"]
    #[doc = "   The rdma_cm_id must be bound to a local RDMA device before calling this"]
    #[doc = "   function, and the protection domain must be for that same device."]
    #[doc = "   QPs allocated to an rdma_cm_id are automatically transitioned by the"]
    #[doc = "   librdmacm through their states.  After being allocated, the QP will be"]
    #[doc = "   ready to handle posting of receives.  If the QP is unconnected, it will"]
    #[doc = "   be ready to post sends."]
    #[doc = "   If pd is NULL, then the QP will be allocated using a default protection"]
    #[doc = "   domain associated with the underlying RDMA device."]
    #[doc = " See also:"]
    #[doc = "   rdma_bind_addr, rdma_resolve_addr, rdma_destroy_qp, ibv_create_qp,"]
    #[doc = "   ibv_modify_qp"]
    pub fn rdma_create_qp(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_qp_ex(
        id: *mut rdma_cm_id,
        qp_init_attr: *mut ibv_qp_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_destroy_qp - Deallocate a QP."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Destroy a QP allocated on the rdma_cm_id."]
    #[doc = " Notes:"]
    #[doc = "   Users must destroy any QP associated with an rdma_cm_id before"]
    #[doc = "   destroying the ID."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_qp, rdma_destroy_id, ibv_destroy_qp"]
    pub fn rdma_destroy_qp(id: *mut rdma_cm_id);
}
extern "C" {
    #[doc = " rdma_connect - Initiate an active connection request."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @conn_param: optional connection parameters."]
    #[doc = " Description:"]
    #[doc = "   For a connected rdma_cm_id, this call initiates a connection request"]
    #[doc = "   to a remote destination.  For an unconnected rdma_cm_id, it initiates"]
    #[doc = "   a lookup of the remote QP providing the datagram service."]
    #[doc = " Notes:"]
    #[doc = "   Users must have resolved a route to the destination address"]
    #[doc = "   by having called rdma_resolve_route before calling this routine."]
    #[doc = "   A user may override the default connection parameters and exchange"]
    #[doc = "   private data as part of the connection by using the conn_param parameter."]
    #[doc = " See also:"]
    #[doc = "   rdma_resolve_route, rdma_disconnect, rdma_listen, rdma_get_cm_event"]
    pub fn rdma_connect(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_establish - Complete an active connection request."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Acknowledge an incoming connection response event and complete the"]
    #[doc = "   connection establishment."]
    #[doc = " Notes:"]
    #[doc = "   If a QP has not been created on the rdma_cm_id, this function should be"]
    #[doc = "   called by the active side to complete the connection, after getting connect"]
    #[doc = "   response event. This will trigger a connection established event on the"]
    #[doc = "   passive side."]
    #[doc = "   This function should not be used on an rdma_cm_id on which a QP has been"]
    #[doc = "   created."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_disconnect, rdma_get_cm_event"]
    pub fn rdma_establish(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_listen - Listen for incoming connection requests."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @backlog: backlog of incoming connection requests."]
    #[doc = " Description:"]
    #[doc = "   Initiates a listen for incoming connection requests or datagram service"]
    #[doc = "   lookup.  The listen will be restricted to the locally bound source"]
    #[doc = "   address."]
    #[doc = " Notes:"]
    #[doc = "   Users must have bound the rdma_cm_id to a local address by calling"]
    #[doc = "   rdma_bind_addr before calling this routine.  If the rdma_cm_id is"]
    #[doc = "   bound to a specific IP address, the listen will be restricted to that"]
    #[doc = "   address and the associated RDMA device.  If the rdma_cm_id is bound"]
    #[doc = "   to an RDMA port number only, the listen will occur across all RDMA"]
    #[doc = "   devices."]
    #[doc = " See also:"]
    #[doc = "   rdma_bind_addr, rdma_connect, rdma_accept, rdma_reject, rdma_get_cm_event"]
    pub fn rdma_listen(
        id: *mut rdma_cm_id,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_get_request"]
    pub fn rdma_get_request(
        listen: *mut rdma_cm_id,
        id: *mut *mut rdma_cm_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_accept - Called to accept a connection request."]
    #[doc = " @id: Connection identifier associated with the request."]
    #[doc = " @conn_param: Optional information needed to establish the connection."]
    #[doc = " Description:"]
    #[doc = "   Called from the listening side to accept a connection or datagram"]
    #[doc = "   service lookup request."]
    #[doc = " Notes:"]
    #[doc = "   Unlike the socket accept routine, rdma_accept is not called on a"]
    #[doc = "   listening rdma_cm_id.  Instead, after calling rdma_listen, the user"]
    #[doc = "   waits for a connection request event to occur.  Connection request"]
    #[doc = "   events give the user a newly created rdma_cm_id, similar to a new"]
    #[doc = "   socket, but the rdma_cm_id is bound to a specific RDMA device."]
    #[doc = "   rdma_accept is called on the new rdma_cm_id."]
    #[doc = "   A user may override the default connection parameters and exchange"]
    #[doc = "   private data as part of the connection by using the conn_param parameter."]
    #[doc = " See also:"]
    #[doc = "   rdma_listen, rdma_reject, rdma_get_cm_event"]
    pub fn rdma_accept(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_reject - Called to reject a connection request."]
    #[doc = " @id: Connection identifier associated with the request."]
    #[doc = " @private_data: Optional private data to send with the reject message."]
    #[doc = " @private_data_len: Size of the private_data to send, in bytes."]
    #[doc = " Description:"]
    #[doc = "   Called from the listening side to reject a connection or datagram"]
    #[doc = "   service lookup request."]
    #[doc = " Notes:"]
    #[doc = "   After receiving a connection request event, a user may call rdma_reject"]
    #[doc = "   to reject the request.  If the underlying RDMA transport supports"]
    #[doc = "   private data in the reject message, the specified data will be passed to"]
    #[doc = "   the remote side."]
    #[doc = " See also:"]
    #[doc = "   rdma_listen, rdma_accept, rdma_get_cm_event"]
    pub fn rdma_reject(
        id: *mut rdma_cm_id,
        private_data: *const ::std::os::raw::c_void,
        private_data_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_reject_ece - Called to reject a connection request with ECE"]
    #[doc = " rejected reason."]
    #[doc = " The same as rdma_reject()"]
    pub fn rdma_reject_ece(
        id: *mut rdma_cm_id,
        private_data: *const ::std::os::raw::c_void,
        private_data_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_notify - Notifies the librdmacm of an asynchronous event."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @event: Asynchronous event."]
    #[doc = " Description:"]
    #[doc = "   Used to notify the librdmacm of asynchronous events that have occurred"]
    #[doc = "   on a QP associated with the rdma_cm_id."]
    #[doc = " Notes:"]
    #[doc = "   Asynchronous events that occur on a QP are reported through the user's"]
    #[doc = "   device event handler.  This routine is used to notify the librdmacm of"]
    #[doc = "   communication events.  In most cases, use of this routine is not"]
    #[doc = "   necessary, however if connection establishment is done out of band"]
    #[doc = "   (such as done through Infiniband), it's possible to receive data on a"]
    #[doc = "   QP that is not yet considered connected.  This routine forces the"]
    #[doc = "   connection into an established state in this case in order to handle"]
    #[doc = "   the rare situation where the connection never forms on its own."]
    #[doc = "   Events that should be reported to the CM are: IB_EVENT_COMM_EST."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_accept, rdma_listen"]
    pub fn rdma_notify(id: *mut rdma_cm_id, event: ibv_event_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_disconnect - This function disconnects a connection."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Disconnects a connection and transitions any associated QP to the"]
    #[doc = "   error state."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_listen, rdma_accept"]
    pub fn rdma_disconnect(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_join_multicast - Joins a multicast group."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @addr: Multicast address identifying the group to join."]
    #[doc = " @context: User-defined context associated with the join request."]
    #[doc = " Description:"]
    #[doc = "   Joins a multicast group and attaches an associated QP to the group."]
    #[doc = " Notes:"]
    #[doc = "   Before joining a multicast group, the rdma_cm_id must be bound to"]
    #[doc = "   an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of"]
    #[doc = "   rdma_resolve_addr requires the local routing tables to resolve the"]
    #[doc = "   multicast address to an RDMA device.  The user must call"]
    #[doc = "   rdma_leave_multicast to leave the multicast group and release any"]
    #[doc = "   multicast resources.  The context is returned to the user through"]
    #[doc = "   the private_data field in the rdma_cm_event."]
    #[doc = " See also:"]
    #[doc = "   rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_join_multicast(
        id: *mut rdma_cm_id,
        addr: *mut sockaddr,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_leave_multicast - Leaves a multicast group."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @addr: Multicast address identifying the group to leave."]
    #[doc = " Description:"]
    #[doc = "   Leaves a multicast group and detaches an associated QP from the group."]
    #[doc = " Notes:"]
    #[doc = "   Calling this function before a group has been fully joined results in"]
    #[doc = "   canceling the join operation.  Users should be aware that messages"]
    #[doc = "   received from the multicast group may stilled be queued for"]
    #[doc = "   completion processing immediately after leaving a multicast group."]
    #[doc = "   Destroying an rdma_cm_id will automatically leave all multicast groups."]
    #[doc = " See also:"]
    #[doc = "   rdma_join_multicast, rdma_destroy_qp"]
    pub fn rdma_leave_multicast(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_multicast_ex - Joins a multicast group with options."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @mc_join_attr: Extensive struct containing multicast join parameters."]
    #[doc = " @context: User-defined context associated with the join request."]
    #[doc = " Description:"]
    #[doc = "  Joins a multicast group with options. Currently supporting MC join flags."]
    #[doc = "  The QP will be attached based on the given join flag."]
    #[doc = "  Join message will be sent according to the join flag."]
    #[doc = " Notes:"]
    #[doc = "  Before joining a multicast group, the rdma_cm_id must be bound to"]
    #[doc = "  an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of"]
    #[doc = "  rdma_resolve_addr requires the local routing tables to resolve the"]
    #[doc = "  multicast address to an RDMA device.  The user must call"]
    #[doc = "  rdma_leave_multicast to leave the multicast group and release any"]
    #[doc = "  multicast resources.  The context is returned to the user through"]
    #[doc = "  the private_data field in the rdma_cm_event."]
    #[doc = " See also:"]
    #[doc = "  rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_join_multicast_ex(
        id: *mut rdma_cm_id,
        mc_join_attr: *mut rdma_cm_join_mc_attr_ex,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_get_cm_event - Retrieves the next pending communication event."]
    #[doc = " @channel: Event channel to check for events."]
    #[doc = " @event: Allocated information about the next communication event."]
    #[doc = " Description:"]
    #[doc = "   Retrieves a communication event.  If no events are pending, by default,"]
    #[doc = "   the call will block until an event is received."]
    #[doc = " Notes:"]
    #[doc = "   The default synchronous behavior of this routine can be changed by"]
    #[doc = "   modifying the file descriptor associated with the given channel.  All"]
    #[doc = "   events that are reported must be acknowledged by calling rdma_ack_cm_event."]
    #[doc = "   Destruction of an rdma_cm_id will block until related events have been"]
    #[doc = "   acknowledged."]
    #[doc = " See also:"]
    #[doc = "   rdma_ack_cm_event, rdma_create_event_channel, rdma_event_str"]
    pub fn rdma_get_cm_event(
        channel: *mut rdma_event_channel,
        event: *mut *mut rdma_cm_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_ack_cm_event - Free a communication event."]
    #[doc = " @event: Event to be released."]
    #[doc = " Description:"]
    #[doc = "   All events which are allocated by rdma_get_cm_event must be released,"]
    #[doc = "   there should be a one-to-one correspondence between successful gets"]
    #[doc = "   and acks."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event, rdma_destroy_id"]
    pub fn rdma_ack_cm_event(event: *mut rdma_cm_event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_src_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    pub fn rdma_get_dst_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    #[doc = " rdma_get_devices - Get list of RDMA devices currently available."]
    #[doc = " @num_devices: If non-NULL, set to the number of devices returned."]
    #[doc = " Description:"]
    #[doc = "   Return a NULL-terminated array of opened RDMA devices.  Callers can use"]
    #[doc = "   this routine to allocate resources on specific RDMA devices that will be"]
    #[doc = "   shared across multiple rdma_cm_id's."]
    #[doc = " Notes:"]
    #[doc = "   The returned array must be released by calling rdma_free_devices.  Devices"]
    #[doc = "   remain opened while the librdmacm is loaded."]
    #[doc = " See also:"]
    #[doc = "   rdma_free_devices"]
    pub fn rdma_get_devices(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_context;
}
extern "C" {
    #[doc = " rdma_free_devices - Frees the list of devices returned by rdma_get_devices."]
    #[doc = " @list: List of devices returned from rdma_get_devices."]
    #[doc = " Description:"]
    #[doc = "   Frees the device array returned by rdma_get_devices."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_devices"]
    pub fn rdma_free_devices(list: *mut *mut ibv_context);
}
extern "C" {
    #[doc = " rdma_event_str - Returns a string representation of an rdma cm event."]
    #[doc = " @event: Asynchronous event."]
    #[doc = " Description:"]
    #[doc = "   Returns a string representation of an asynchronous event."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event"]
    pub fn rdma_event_str(event: rdma_cm_event_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " rdma_set_option - Set options for an rdma_cm_id."]
    #[doc = " @id: Communication identifier to set option for."]
    #[doc = " @level: Protocol level of the option to set."]
    #[doc = " @optname: Name of the option to set."]
    #[doc = " @optval: Reference to the option data."]
    #[doc = " @optlen: The size of the %optval buffer."]
    pub fn rdma_set_option(
        id: *mut rdma_cm_id,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_migrate_id - Move an rdma_cm_id to a new event channel."]
    #[doc = " @id: Communication identifier to migrate."]
    #[doc = " @channel: New event channel for rdma_cm_id events."]
    pub fn rdma_migrate_id(
        id: *mut rdma_cm_id,
        channel: *mut rdma_event_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_getaddrinfo - RDMA address and route resolution service."]
    pub fn rdma_getaddrinfo(
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const rdma_addrinfo,
        res: *mut *mut rdma_addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_freeaddrinfo(res: *mut rdma_addrinfo);
}
extern "C" {
    #[doc = " rdma_init_qp_attr - Returns QP attributes."]
    #[doc = " @id: Communication identifier."]
    #[doc = " @qp_attr: A reference to a QP attributes struct containing"]
    #[doc = " response information."]
    #[doc = " @qp_attr_mask: A reference to a QP attributes mask containing"]
    #[doc = " response information."]
    pub fn rdma_init_qp_attr(
        id: *mut rdma_cm_id,
        qp_attr: *mut ibv_qp_attr,
        qp_attr_mask: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_set_local_ece - Set local ECE options to be used for REQ/REP"]
    #[doc = " communication. In use to implement ECE handshake in external QP."]
    #[doc = " @id: Communication identifier to establish connection"]
    #[doc = " @ece: ECE parameters"]
    pub fn rdma_set_local_ece(id: *mut rdma_cm_id, ece: *mut ibv_ece) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_get_remote_ece - Provide remote ECE parameters as received"]
    #[doc = " in REQ/REP events. In use to implement ECE handshake in external QP."]
    #[doc = " @id: Communication identifier to establish connection"]
    #[doc = " @ece: ECE parameters"]
    pub fn rdma_get_remote_ece(id: *mut rdma_cm_id, ece: *mut ibv_ece) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_srq(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        attr: *mut ibv_srq_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_srq_ex(
        id: *mut rdma_cm_id,
        attr: *mut ibv_srq_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_destroy_srq(id: *mut rdma_cm_id);
}
pub const _RS_IBV_ACCESS_OPTIONAL_RANGE: ::std::os::raw::c_uint = 1072693248;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct verbs_ex_private {
    pub _address: u8,
}
